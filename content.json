{"meta":{"title":"WinNote","subtitle":"","description":"零碎MD文档收集 | 生命在于折腾","author":"winotmk","url":"https://winotmk.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-11-01T08:17:29.000Z","updated":"2021-11-01T08:19:23.000Z","comments":false,"path":"categories/index.html","permalink":"https://winotmk.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-01T08:21:06.000Z","updated":"2021-11-01T08:21:34.000Z","comments":false,"path":"tags/index.html","permalink":"https://winotmk.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"calibre_web的pdf封面提取问题","slug":"240925_calibre_web的pdf封面提取问题","date":"2024-09-24T16:00:00.000Z","updated":"2024-09-25T06:06:41.760Z","comments":true,"path":"240925_calibre_web的pdf封面提取问题/","link":"","permalink":"https://winotmk.github.io/240925_calibre_web%E7%9A%84pdf%E5%B0%81%E9%9D%A2%E6%8F%90%E5%8F%96%E9%97%AE%E9%A2%98/","excerpt":"在用johngong/calibre-web:latest这个镜像 https://hub.docker.com/r/johngong/calibre-web作为自己nas上的图书馆时发现pdf文件无法生成封面， 断断续续排查了两周，百思不得解，尝试过： 设置imagemagick的policy.xml文件(/etc/Imagemagick/policy.xml) 使用lscr.io/linuxserver/calibre-web:latest的镜像 自己重新构建镜像 重新安装calibre-web包和重装imagemagick包都解决不了，总之是十分折腾，最后认为可能是johngong/calibre-web:latest可能是里少了一个imagemagick-pdf包 最终有效的解决方法的折腾流程我尝试上传pdf文件，然后打开日志（日志级别设置为DEBUG）查看文件：/config/calbre-web/calbre-web.log有这么一行： 12[2024-09-25 12:10:22,144] WARN &#123;cps.uploader:237&#125; Cannot extract cover image, using default: no decode delegate for this image format `PDF&#x27; @ error/constitute.c/ReadImage/746[2024-09-25 12:10:22,145] WARN &#123;cps.uploader:238&#125; On Windows this error could be caused by missing ghostscript PDF转就转不出来所以找到了：https://github.com/ImageMagick/ImageMagick/issues/6148 1apk add --no-cache imagemagick imagemagick-pdf 安装完以后，再次尝试上传pdf格式的书，就看见封面辣！！","text":"在用johngong/calibre-web:latest这个镜像 https://hub.docker.com/r/johngong/calibre-web作为自己nas上的图书馆时发现pdf文件无法生成封面， 断断续续排查了两周，百思不得解，尝试过： 设置imagemagick的policy.xml文件(/etc/Imagemagick/policy.xml) 使用lscr.io/linuxserver/calibre-web:latest的镜像 自己重新构建镜像 重新安装calibre-web包和重装imagemagick包都解决不了，总之是十分折腾，最后认为可能是johngong/calibre-web:latest可能是里少了一个imagemagick-pdf包 最终有效的解决方法的折腾流程我尝试上传pdf文件，然后打开日志（日志级别设置为DEBUG）查看文件：/config/calbre-web/calbre-web.log有这么一行： 12[2024-09-25 12:10:22,144] WARN &#123;cps.uploader:237&#125; Cannot extract cover image, using default: no decode delegate for this image format `PDF&#x27; @ error/constitute.c/ReadImage/746[2024-09-25 12:10:22,145] WARN &#123;cps.uploader:238&#125; On Windows this error could be caused by missing ghostscript PDF转就转不出来所以找到了：https://github.com/ImageMagick/ImageMagick/issues/6148 1apk add --no-cache imagemagick imagemagick-pdf 安装完以后，再次尝试上传pdf格式的书，就看见封面辣！！ johngong/calibre-web的一些设置https://github.com/gshang2017/docker/issues/133如果一编辑图书的元数据就卡死，可用尝试：这两条设置为true,则这里不会出现google等选项，家里的nas没有梯子环境，反而会导致卡死，所以禁用google吧。。也没啥用 弯路这里想记一下这个弯路，在calibre-web的FAQ里赫然记着有关pdf文件转不出封面的解决办法，说要改https://github.com/janeczku/calibre-web/wiki/FAQ#what-to-do-if-cover-pictures-are-not-extracted-from-pdf-files所以可以有/etc/Imagemagick/policy.xml: 123&lt;policymap&gt; &lt;policy domain=&quot;coder&quot; rights=&quot;read | write&quot; pattern=&quot;&#123;MSVG,MVG,PS,PDF,RSVG,SVG,XPS&#125;&quot; /&gt;&lt;/policymap&gt; 这是最容易找到的一种解法，但我自己试了无用，没有上面的装apk add imagemagick-pdf好使 尝试出来的另一种PDF封面提取可行方法这样做出来的calibre-web镜像可以实现PDF转换，但是没有电子书格式转换，没有禁用google元数据搜索，没有中文环境，懒得自己做了，还是修修用johngong/calibre-web包吧为了试验，我用FROM ubuntu:latest作为镜像基底，然后： 装calibre-web安装calibre-web：https://github.com/janeczku/calibre-web?tab=readme-ov-file#installationhttps://github.com/janeczku/calibre-web/wiki/Dependencies-in-Calibre-Web-Linux-and-Windows这里也有提到https://chenjiehua.me/others/calibre-web-personal-book-store.html 12pip install calibrewebpip install calibreweb[metadata] 装imagemagick然后安装imagemagick官方：https://imagemagick.org/script/download.php也有提到：https://www.cnblogs.com/echohye/p/17727865.html 1apt install imagemagick 装完后convert和magick命令应当是可用的 手动装imagemagick或者我用上面官方的magick文件手动配貌似也行：先把magick文件放入根目录 1./magick --appimage-extract https://docs.appimage.org/user-guide/troubleshooting/fuse.html提到了可以用--appimage-extract直接释放出软件包来会发现释放出来文件在/squashfs-root目录里设置环境变量： 123export MAGICK_HOME=&quot;/squashfs-root/usr&quot;export PATH=&quot;$MAGICK_HOME/bin:$PATH&quot;export LD_LIBRARY_PATH=&quot;$&#123;LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:&#125;$MAGICK_HOME/lib&quot; 然后imagemagick应该就能用了。。 其他lscr.io/linuxserver/calibre-web:latest这个镜像也不小，但功能还算完整，上传pdf可直接显示封面，但不是中文环境，而且部署到我的nas上后死活传不了新书说什么无法写入，懒得深究了，弃之","categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"},{"name":"calibre_web","slug":"calibre-web","permalink":"https://winotmk.github.io/tags/calibre-web/"}]},{"title":"给docker容器内配置中文环境(minecraft开服相关)","slug":"240815_给docker容器内配置中文环境","date":"2024-08-14T16:00:00.000Z","updated":"2024-08-15T06:13:54.402Z","comments":true,"path":"240815_给docker容器内配置中文环境/","link":"","permalink":"https://winotmk.github.io/240815_%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83/","excerpt":"","text":"最近找到个整合包（因为懒得一个个翻bbshttps://www.bilibili.com/read/cv7403697/?spm_id_from=333.999.collection.opus.click这包里的mod和之前自己开的服务器高度相似，太棒啦，从1.7.10直升1.12.2，基本还都是熟悉的味道才知道mcbbs已经无了，然后才可发现mc百科已经这么好用了，连接直连发布curseforge和github，省去搬运步骤，也蛮好的！服务端有了，想通过docker容器部署到我的群晖NAS上，DS720+扩容了根16G内存条放着也是放着 选取docker镜像docker hub里有官方镜像，用的是这个，体积精简，只运行环境jre就够了https://hub.docker.com/_/openjdk/tags?page=1&amp;page_size=&amp;name=8u342&amp;ordering=所以直接 1docker pull openjdk:8u342-jre-slim 然后直接这样运行就好了 1234567docker run -it -d \\-p 25565:25565 \\-v E:\\game\\MC\\1.12.2mohist_服务端:/mc \\-w /mc \\--name MC1122 \\openjdk:8u342-jre-slim \\java -Xms2G -Xmx8G -XX:+UseG1GC -XX:+AggressiveOpts -XX:+UseCompressedOops -jar Mohist-1.12.2-c950429-server.jar nogui 虽然长，但是总的来说挺简单，用openjdk:8u342-jre-slim镜像运行java命令罢了，但是！出现了一个人让人感觉不爽的小问题，服务端的log输出以及游戏内服务端来的输出都是英文的，这在之前直接windows运行时不是这样的，所以第一反应是语言环境问题 设置环境变量在docker run的时候加上个参数-e LANG=&quot;zh_CN.UTF-8&quot;，类似export LANG=zh_CN.UTF-8确定环境变量生效了：但没解决问题，反而似乎导致启动的时候不认识中文的mod文件名了 在查找这个之后：docker 容器设置中文环境发现单纯设置LANG的变量不行，容器里就没有中文字符集的 查看已有语言1locale -a 安装中文环境使用DockerFile的方式快速构建一个基础镜像，解决中文环境问题所以安装中文环境的命令可以是： 1apt-get install -y language-pack-zh-hans 但这样不行！因为这个是ubuntu的命令，查看我的docker镜像的信息发现是以debian基底的 看到:Debian系统安装中文包 1dpkg-reconfigure locales 然后再选zh_CN.UTF-8，可行，但是集成到镜像里没那么好使，还好有别的方法 制作新镜像参考：dockerfile文件中给debian设置中文支持 dockerfile1234FROM openjdk:8u342-jre-slimRUN apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get install -y locales &amp;&amp; localedef -c -f UTF-8 -i zh_CN zh_CN.utf8WORKDIR /mcENV LANG zh_CN.UTF-8 保存为dockerfile文件然后 1docker build -t jre8u342_ch . 测试运行123456docker run -it -d \\-p 25565:25565 \\-v E:\\game\\MC\\1.12.2mohist_服务端:/mc \\--name MC1122 \\jre8u342_ch:latest \\java -Xms2G -Xmx8G -XX:+UseG1GC -XX:+AggressiveOpts -XX:+UseCompressedOops -jar Mohist-1.12.2-c950429-server.jar nogui 因为dockerfile里已经设置过WORKDIR了所以不需要-w参数 这下不会报英文了游戏里也是中文环境的返回信息 部署到群晖先把做好的镜像打包出来，方便传到群晖NAS里 1docker save -o jre8u342_ch.tar jre8u342_ch:latest 先导入这个镜像然后简单配置一下端口和mc服务器目录就可以了,和上面的docker run其实是一样的端口的25565是游戏端口25575用作管理，下面会提到 服务器远程管理用容器托管运行了，上哪去敲/op xxxx和/stop之类的管理命令呢？可以用rcon方案！https://wiki.vg/RCON具体就是用这个软件：https://github.com/Tiiffi/mcrcon 安装和服务端配置：1234git clone https://github.com/Tiiffi/mcrcon.gitcd mcrconmakesudo make install 然后服务端也要配置一下，在server.properties里的 1enable-rcon=false 改为 123enable-rcon=truercon.password=your_passwdrcon.port=25575 用法：先连接 1mcrcon -H 服务器地址 -p your_passwd 然后就可以一样敲各种minecraft管理命令了 好了不说了博主我要去挖矿开荒了 参考debian文档，第 8 章 国际化和本地化：https://www.debian.org/doc/manuals/debian-reference/ch08.zh-cn.html#_rationale_for_utf_8_locale 类似的打包好的docker环境MC服务器镜像有：https://github.com/itzg/docker-minecraft-server/tree/master对我来说功能有点多，只是参考参考","categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"},{"name":"minecraft","slug":"minecraft","permalink":"https://winotmk.github.io/tags/minecraft/"}]},{"title":"python格式化字符串的方法","slug":"240810_python格式化字符串的方法","date":"2024-08-09T16:00:00.000Z","updated":"2024-08-10T15:09:54.088Z","comments":true,"path":"240810_python格式化字符串的方法/","link":"","permalink":"https://winotmk.github.io/240810_python%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"问题:例如print(&quot;位置过期:%-6.0f秒&quot;%cachetime)的%-6.0f是什么意思？%-6.0f里的每一个字符都是有意义的 在 Python 中，%-6.0f 是一种格式化字符串的方法，用于格式化浮点数 cachetime 的值。让我们来逐部分解释： 解释%：% 是格式化操作符，用于将后面指定的变量格式化并插入到字符串中。 -6：-6 是一个宽度说明符，它指定了格式化后输出的最小宽度为 6 个字符。- 表示左对齐。如果没有这个符号（即为默认的右对齐），数字会向右对齐。如果数字宽度不足 6 个字符，则会在数字右侧补充空格，以达到 6 个字符的总宽度。 .0：.0 指定了浮点数的小数部分显示 0 位（即不显示小数部分）。因此，浮点数会被显示为整数形式。 f：f 表示将变量作为浮点数进行格式化。ps:如果不用格式化字符串，直接print(cachetime)会报错，因为不能直接打印浮点数，可以print(str(cachetime)) 例子假设 cachetime 的值是 820.75，则： 123cachetime = 820.75formatted_string = u&quot;位置过期:%-6.0f秒&quot; % cachetimeprint(formatted_string) 输出： 1位置过期:821 秒 输出解释：%-6.0f 将 820.75 格式化为 821（由于 .0 不显示小数部分）。821 左对齐，占用至少 6 个字符的位置。如果 821 只有 3 个字符，右边会填充 3 个空格，使得总宽度为 6 个字符。如果你将数字换成更小的，比如 10： 123cachetime = 10formatted_string = u&quot;位置过期:%-6.0f秒&quot; % cachetimeprint(formatted_string) 输出： 1位置过期:10 秒 10 会左对齐，后面会补充 4 个空格，使总长度达到 6 个字符。","categories":[{"name":"python","slug":"python","permalink":"https://winotmk.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://winotmk.github.io/tags/python/"},{"name":"开发","slug":"开发","permalink":"https://winotmk.github.io/tags/%E5%BC%80%E5%8F%91/"}]},{"title":"网站框架收集","slug":"240806_网站框架收集","date":"2024-08-05T16:00:00.000Z","updated":"2024-08-14T08:04:39.391Z","comments":true,"path":"240806_网站框架收集/","link":"","permalink":"https://winotmk.github.io/240806_%E7%BD%91%E7%AB%99%E6%A1%86%E6%9E%B6%E6%94%B6%E9%9B%86/","excerpt":"其实自己很长一段（接下来将来可能也会）时间内有两个网站，一个是习惯稍微正式点的东西写在：https://www.winotmk.com/是我的第一个网站，基于wordpress的，买的包年虚拟服务器，但很多内容年久失修，而且刚架设的时候什么也不知道，一点点摸通服务器，备案，注册域名之类的，那会儿还挺流行wordpress，似乎也没有别的更多的选择同时还有一个https://md.winotmk.com/(https://winotmk.github.io/)由hexo驱动的纯静态md文档网站，比较随意，想到啥写啥，构建方式也比较特别，是运行在云服务的容器里，静态文章则是在阿里云nas存储里，网站生成后托管在github，同时cdn加速似乎md站可以用更放松的心情去记录，慢慢的文章比主站还多了？！ 因为目前主站的各种小毛病（也不是不能用）所以经常考虑要不要把它换套别的结构，网上一搜确实有比如一键wordpress转hugo的方案，总之先记着，不一定用。因为当初20块买了套便宜的wordpress皮肤，然后在此基础上魔改各种css，已然改成了忒修斯之船，全丢弃了还是挺可惜的（沉没成本2333 网站生成/框架typecho Typecho 是一款基于 PHP 的博客软件，旨在成为世界上最强大的博客引擎https://github.com/typecho/typechohttps://typecho.org/ 这个好在和wordpress一样也是PHP的，想必能很快的迁移过来吧，而且目测更轻量，就是可能还是得租虚拟服务器了","text":"其实自己很长一段（接下来将来可能也会）时间内有两个网站，一个是习惯稍微正式点的东西写在：https://www.winotmk.com/是我的第一个网站，基于wordpress的，买的包年虚拟服务器，但很多内容年久失修，而且刚架设的时候什么也不知道，一点点摸通服务器，备案，注册域名之类的，那会儿还挺流行wordpress，似乎也没有别的更多的选择同时还有一个https://md.winotmk.com/(https://winotmk.github.io/)由hexo驱动的纯静态md文档网站，比较随意，想到啥写啥，构建方式也比较特别，是运行在云服务的容器里，静态文章则是在阿里云nas存储里，网站生成后托管在github，同时cdn加速似乎md站可以用更放松的心情去记录，慢慢的文章比主站还多了？！ 因为目前主站的各种小毛病（也不是不能用）所以经常考虑要不要把它换套别的结构，网上一搜确实有比如一键wordpress转hugo的方案，总之先记着，不一定用。因为当初20块买了套便宜的wordpress皮肤，然后在此基础上魔改各种css，已然改成了忒修斯之船，全丢弃了还是挺可惜的（沉没成本2333 网站生成/框架typecho Typecho 是一款基于 PHP 的博客软件，旨在成为世界上最强大的博客引擎https://github.com/typecho/typechohttps://typecho.org/ 这个好在和wordpress一样也是PHP的，想必能很快的迁移过来吧，而且目测更轻量，就是可能还是得租虚拟服务器了 预览博客：https://xhhdd.cc/index.php/archives/27/https://cfanlost.com/ hugohttps://gohugo.io/ 似乎是类hexo生成静态网页，然后可以塞到github托管的 pelican Pelican 是一个用Python编写的静态站点生成器，允许您通过编写 Markdown、reStructuredText 和 HTML 等格式的文本文件来创建网站https://github.com/getpelican/pelican 听起来类似hexo和hugo，只是一个nodejs，一个go，这个则是python做的（真好啊 jekyllrb 将纯文本转换为静态网站和博客https://jekyllrb.com/ 应该和上面类似，同样是静态文章生成，部署到github 预览博客：https://jaminzhang.github.io/linux/Change-Linux-System-Locale-Envs/ 皮肤/主题typechohandsomehttps://www.ihewro.com/archives/489/ pelicanattilahttps://github.com/arulrajnet/attila 预览博客：https://leonis.cc/sui-sui-nian/2023-10-31-cloudflare-dns-of-blog.html 评论系统walinehttps://github.com/walinejs/waline","categories":[{"name":"web","slug":"web","permalink":"https://winotmk.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://winotmk.github.io/tags/web/"},{"name":"博客","slug":"博客","permalink":"https://winotmk.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"用容器来运行streamlit","slug":"240724_用容器来运行streamlit","date":"2024-07-23T16:00:00.000Z","updated":"2024-08-06T07:50:36.631Z","comments":true,"path":"240724_用容器来运行streamlit/","link":"","permalink":"https://winotmk.github.io/240724_%E7%94%A8%E5%AE%B9%E5%99%A8%E6%9D%A5%E8%BF%90%E8%A1%8Cstreamlit/","excerpt":"一开始玩这个的时候就在想用docker跑，因为实在不想在本机里搭各种乱七八糟的环境，也懒得用Anaconda那样的中间环境，总感觉本地跑个模型才用得上那种大玩意儿，于是在dockerhub上找了找一些已有的可用镜像：https://hub.docker.com/r/aminehy/docker-streamlit-apphttps://hub.docker.com/r/samdobson/streamlit就是镜像build都好几年前了，实测目前有些新的例程都跑不了，还是自己做个镜像吧 制作dockerfilehttps://docs.streamlit.io/deploy/tutorials/docker好在官网已给出方案这是我微改后的： 12345678910111213141516171819202122# app/DockerfileFROM python:3.9-slimWORKDIR /appRUN apt-get update &amp;&amp; apt-get install -y \\ build-essential \\ curl \\ software-properties-common \\ git \\ &amp;&amp; rm -rf /var/lib/apt/lists/*RUN git clone https://github.com/streamlit/streamlit-example.git .RUN pip3 install -r requirements.txtEXPOSE 8501HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/healthCMD [&quot;streamlit&quot;, &quot;run&quot;, &quot;main.py&quot;, &quot;--server.port=8501&quot;, &quot;--server.address=0.0.0.0&quot;]","text":"一开始玩这个的时候就在想用docker跑，因为实在不想在本机里搭各种乱七八糟的环境，也懒得用Anaconda那样的中间环境，总感觉本地跑个模型才用得上那种大玩意儿，于是在dockerhub上找了找一些已有的可用镜像：https://hub.docker.com/r/aminehy/docker-streamlit-apphttps://hub.docker.com/r/samdobson/streamlit就是镜像build都好几年前了，实测目前有些新的例程都跑不了，还是自己做个镜像吧 制作dockerfilehttps://docs.streamlit.io/deploy/tutorials/docker好在官网已给出方案这是我微改后的： 12345678910111213141516171819202122# app/DockerfileFROM python:3.9-slimWORKDIR /appRUN apt-get update &amp;&amp; apt-get install -y \\ build-essential \\ curl \\ software-properties-common \\ git \\ &amp;&amp; rm -rf /var/lib/apt/lists/*RUN git clone https://github.com/streamlit/streamlit-example.git .RUN pip3 install -r requirements.txtEXPOSE 8501HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/healthCMD [&quot;streamlit&quot;, &quot;run&quot;, &quot;main.py&quot;, &quot;--server.port=8501&quot;, &quot;--server.address=0.0.0.0&quot;] 主要就最后一行并没有用ENTRYPOINT，因为记得这个不是必须，用CMD的好处是非常方便的就能修改docker run时要运行的内容 构建和使用镜像打开CMD，CD到这个Dockerfile保存的目录下docker build -t streamlit_winotmk:latest . 点不要落下 然后就可用来运行任意py的app文件了docker run -ti --rm -p 8501:8501 -v $(pwd):/app streamlit_winotmk:latest streamlit run name_main_file.py$(pwd)换成宿主机的目录，记得暴露8501的默认端口我这里目录是C:\\Cloud\\docker\\streamlit\\demo3\\examples所以直接:docker run -ti --rm -p 8501:8501 -v C:\\Cloud\\docker\\streamlit\\demo3\\examples:/app streamlit_winotmk:latest streamlit run intro.py保持运行并想下次继续用可以docker run -ti -d -p 8501:8501 -v $(pwd):/app --name MystreamlitAPP streamlit_winotmk:latest*用容器跑起来的一些例程APP：","categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"},{"name":"streamlit","slug":"streamlit","permalink":"https://winotmk.github.io/tags/streamlit/"}]},{"title":"段码屏开发—GPT4o带来的一点点震撼","slug":"240724_段码屏开发—GPT4o带来的一点点震撼","date":"2024-07-23T16:00:00.000Z","updated":"2024-08-06T07:50:06.383Z","comments":true,"path":"240724_段码屏开发—GPT4o带来的一点点震撼/","link":"","permalink":"https://winotmk.github.io/240724_%E6%AE%B5%E7%A0%81%E5%B1%8F%E5%BC%80%E5%8F%91%E2%80%94GPT4o%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E9%9C%87%E6%92%BC/","excerpt":"硬件简介屏幕屏幕使用了一块微雪的电子墨水段码屏文档在这里：https://www.waveshare.net/wiki/1.9inch_Segment_e-Paper_Module_Manual MCUMCU方面就是树莓派的PICO，只不过是物理体积更小的版本，用法是一模一样的https://www.waveshare.net/wiki/RP2040-Zero 字节(byte)和比特(bit)的对应最近买了块高颜值段码屏，电子墨水屏原理的，一直没弄明白这个文档里说得是个啥意思，恰好最近尝试使用GPT来解决我遇到的一些编程问题，本来只是抱着试试看的态度，因为自从chatgpt火了以后一直持观望态度，印象中还只是能给它设定模仿人格写写小说一类的，然而这次实在小震撼到我起初这个表对于完全没接触过这块的我完全不动他是什么意思 疑惑的关键在于0x00怎么就全0，而0xff怎么就全1了呢，于是我问GPT：*以下是GPT的回答在这个图表中，每个字节（byte）由 8 个比特（bit）组成，且每个比特都可以存储一个二进制值（0 或 1）。这些比特在图像中对应的像素（pixel）上，决定了每个像素的颜色（例如，黑色或白色）。 理解图表中的内容 像素 (pixel): 从 1 到 16 的编号表示每个像素的位置。 比特 (bit): 每个像素位置对应一个比特，从 7 到 0 代表一个字节中的每一位。 存储的数据: 存储在比特中的数据值（0 或 1）。 对应的颜色: 由数据值决定的像素颜色（黑色或白色）。5。 字节 (byte): 0x00 和 0xff 表示字节的十六进制值。字节和比特的对应关系 一个字节有 8 位，每一位可以是 0 或 1。 0x00 表示 8 个比特全部为 0，转换为二进制是 00000000。 0xff 表示 8 个比特全部为 1，转换为二进制是 11111111。解释示例 0x00 字节: 二进制表示：00000000 每个比特位都是 0，因此对应的像素颜色是黑色。 从像素 1 到 8 的存储数据都是 0，所以对应颜色都是黑色。 0xff 字节: 二进制表示：11111111 每个比特位都是 1，因此对应的像素颜色是白色。 从像素 9 到 16 的存储数据都是 1，所以对应颜色都是白色。示例代码解释如果你想用代码来解释字节和比特之间的关系，可以如下示例：1234567891011121314# 示例字节byte_00 = 0x00 # 所有比特位都是 0byte_ff = 0xff # 所有比特位都是 1# 打印二进制表示print(f&quot;0x00 的二进制表示: &#123;bin(byte_00)[2:].zfill(8)&#125;&quot;)print(f&quot;0xff 的二进制表示: &#123;bin(byte_ff)[2:].zfill(8)&#125;&quot;)# 转换为像素颜色pixels_00 = [&quot;■&quot; if bit == &#x27;0&#x27; else &quot;□&quot; for bit in bin(byte_00)[2:].zfill(8)]pixels_ff = [&quot;■&quot; if bit == &#x27;0&#x27; else &quot;□&quot; for bit in bin(byte_ff)[2:].zfill(8)]print(f&quot;0x00 对应的像素颜色: &#123;&#x27;&#x27;.join(pixels_00)&#125;&quot;)print(f&quot;0xff 对应的像素颜色: &#123;&#x27;&#x27;.join(pixels_ff)&#125;&quot;) 输出12345复制代码0x00 的二进制表示: 000000000xff 的二进制表示: 111111110x00 对应的像素颜色: ■■■■■■■■0xff 对应的像素颜色: □□□□□□□□ 在这里，■ 表示黑色像素，□ 表示白色像素。这个代码示例展示了如何根据字节中的比特值确定像素颜色。","text":"硬件简介屏幕屏幕使用了一块微雪的电子墨水段码屏文档在这里：https://www.waveshare.net/wiki/1.9inch_Segment_e-Paper_Module_Manual MCUMCU方面就是树莓派的PICO，只不过是物理体积更小的版本，用法是一模一样的https://www.waveshare.net/wiki/RP2040-Zero 字节(byte)和比特(bit)的对应最近买了块高颜值段码屏，电子墨水屏原理的，一直没弄明白这个文档里说得是个啥意思，恰好最近尝试使用GPT来解决我遇到的一些编程问题，本来只是抱着试试看的态度，因为自从chatgpt火了以后一直持观望态度，印象中还只是能给它设定模仿人格写写小说一类的，然而这次实在小震撼到我起初这个表对于完全没接触过这块的我完全不动他是什么意思 疑惑的关键在于0x00怎么就全0，而0xff怎么就全1了呢，于是我问GPT：*以下是GPT的回答在这个图表中，每个字节（byte）由 8 个比特（bit）组成，且每个比特都可以存储一个二进制值（0 或 1）。这些比特在图像中对应的像素（pixel）上，决定了每个像素的颜色（例如，黑色或白色）。 理解图表中的内容 像素 (pixel): 从 1 到 16 的编号表示每个像素的位置。 比特 (bit): 每个像素位置对应一个比特，从 7 到 0 代表一个字节中的每一位。 存储的数据: 存储在比特中的数据值（0 或 1）。 对应的颜色: 由数据值决定的像素颜色（黑色或白色）。5。 字节 (byte): 0x00 和 0xff 表示字节的十六进制值。字节和比特的对应关系 一个字节有 8 位，每一位可以是 0 或 1。 0x00 表示 8 个比特全部为 0，转换为二进制是 00000000。 0xff 表示 8 个比特全部为 1，转换为二进制是 11111111。解释示例 0x00 字节: 二进制表示：00000000 每个比特位都是 0，因此对应的像素颜色是黑色。 从像素 1 到 8 的存储数据都是 0，所以对应颜色都是黑色。 0xff 字节: 二进制表示：11111111 每个比特位都是 1，因此对应的像素颜色是白色。 从像素 9 到 16 的存储数据都是 1，所以对应颜色都是白色。示例代码解释如果你想用代码来解释字节和比特之间的关系，可以如下示例：1234567891011121314# 示例字节byte_00 = 0x00 # 所有比特位都是 0byte_ff = 0xff # 所有比特位都是 1# 打印二进制表示print(f&quot;0x00 的二进制表示: &#123;bin(byte_00)[2:].zfill(8)&#125;&quot;)print(f&quot;0xff 的二进制表示: &#123;bin(byte_ff)[2:].zfill(8)&#125;&quot;)# 转换为像素颜色pixels_00 = [&quot;■&quot; if bit == &#x27;0&#x27; else &quot;□&quot; for bit in bin(byte_00)[2:].zfill(8)]pixels_ff = [&quot;■&quot; if bit == &#x27;0&#x27; else &quot;□&quot; for bit in bin(byte_ff)[2:].zfill(8)]print(f&quot;0x00 对应的像素颜色: &#123;&#x27;&#x27;.join(pixels_00)&#125;&quot;)print(f&quot;0xff 对应的像素颜色: &#123;&#x27;&#x27;.join(pixels_ff)&#125;&quot;) 输出12345复制代码0x00 的二进制表示: 000000000xff 的二进制表示: 111111110x00 对应的像素颜色: ■■■■■■■■0xff 对应的像素颜色: □□□□□□□□ 在这里，■ 表示黑色像素，□ 表示白色像素。这个代码示例展示了如何根据字节中的比特值确定像素颜色。 天呐！有理有据条例清晰，秒懂了，原来byte是十六进制要转为二进制的！而8位二进制就可以表示8个数码管的开与关了！ 数字显示与byte的对应 *GPT回答：为了将数字 23.8 和 54.9 表示为 DSPNUM_1in9_off 数组中的十六进制值，我们需要将每一位数字对应的十六进制编码放入数组的正确位置。根据你提供的映射： 0 ：0xbf, 0x1f 1 ：0x00, 0x1f 2 ：0xfd, 0x17 3 ：0xf5, 0x1f 4 ：0x47, 0x1f 5 ：0xf7, 0x1d 6 ：0xff, 0x1d 7 ：0x21, 0x1f 8 ：0xff, 0x1f 9 ：0xf7, 0x1f根据你的要求： 数字 A 为 23.8 十位 2 对应 DSPNUM_1in9_off[1] 和 DSPNUM_1in9_off[2] 个位 3 对应 DSPNUM_1in9_off[3] 和 DSPNUM_1in9_off[4] 小数点后一位 8 对应 DSPNUM_1in9_off[11] 和 DSPNUM_1in9_off[12] 数字 B 为 54.9 十位 5 对应 DSPNUM_1in9_off[5] 和 DSPNUM_1in9_off[6] 个位 4 对应 DSPNUM_1in9_off[7] 和 DSPNUM_1in9_off[8] 小数点后一位 9 对应 DSPNUM_1in9_off[9] 和 DSPNUM_1in9_off[10] 替换数组将这些值替换到数组 DSPNUM_1in9_off 中： 123456789101112131415161718unsigned char DSPNUM_1in9_off[] = &#123; 0x00, // [0] 保持为 0x00 0xfd, // [1] 数字 A 的十位 2 对应 0x17, // [2] 数字 A 的十位 2 对应 0xf5, // [3] 数字 A 的个位 3 对应 0x1f, // [4] 数字 A 的个位 3 对应 0xf7, // [5] 数字 B 的十位 5 对应 0x1d, // [6] 数字 B 的十位 5 对应 0x47, // [7] 数字 B 的个位 4 对应 0x1f, // [8] 数字 B 的个位 4 对应 0xf7, // [9] 数字 B 的小数点后一位 9 对应 0x1f, // [10] 数字 B 的小数点后一位 9 对应 0xff, // [11] 数字 A 的小数点后一位 8 对应 0x1f, // [12] 数字 A 的小数点后一位 8 对应 0x00, // [13] 保持为 0x00 0x00, // [14] 保持为 0x00 0x00 // [15] 保持为 0x00&#125;; 最终数组123unsigned char DSPNUM_1in9_off[] = &#123; 0x00, 0xfd, 0x17, 0xf5, 0x1f, 0xf7, 0x1d, 0x47, 0x1f, 0xf7, 0x1f, 0xff, 0x1f, 0x00, 0x00, 0x00&#125;; 这个数组 DSPNUM_1in9_off 现在包含了你要求的数字 A 和 B 的十六进制表示形式。 GPT准确无误的理解了我的意思，这是这段代码直接得到的结果！！： 动态将数字转换为对应的段码上面一段只是实现了数字到段码的转换，作为一个温度计肯定需要每隔一段时间就将读取的温度传到这个数组里，所以我继续问GPT又准确无误的给了我方案： 动态调整数组的代码为了动态调整 DSPNUM_1in9_off 数组，你可以编写一个函数，根据给定的 A 和 B 数值，动态设置数组的值。这个函数可以使用一个查找表来将数字映射到相应的字节值。 以下是一个实现示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;// 定义数字对应的字节数组unsigned char digit_bytes[10][2] = &#123; &#123;0xbf, 0x1f&#125;, // 0 &#123;0x00, 0x1f&#125;, // 1 &#123;0xfd, 0x17&#125;, // 2 &#123;0xf5, 0x1f&#125;, // 3 &#123;0x47, 0x1f&#125;, // 4 &#123;0xf7, 0x1d&#125;, // 5 &#123;0xff, 0x1d&#125;, // 6 &#123;0x21, 0x1f&#125;, // 7 &#123;0xff, 0x1f&#125;, // 8 &#123;0xf7, 0x1f&#125; // 9&#125;;// 定义DSPNUM_1in9_off数组unsigned char DSPNUM_1in9_off[16] = &#123;0&#125;;// 更新数组的函数void update_display(double A, double B) &#123; // 提取 A 和 B 的各位数字 int A_tens = (int)(A / 10) % 10; int A_units = (int)A % 10; int A_decimal = (int)(A * 10) % 10; int B_tens = (int)(B / 10) % 10; int B_units = (int)B % 10; int B_decimal = (int)(B * 10) % 10; // 设置数字 A DSPNUM_1in9_off[1] = digit_bytes[A_tens][0]; DSPNUM_1in9_off[2] = digit_bytes[A_tens][1]; DSPNUM_1in9_off[3] = digit_bytes[A_units][0]; DSPNUM_1in9_off[4] = digit_bytes[A_units][1]; DSPNUM_1in9_off[11] = digit_bytes[A_decimal][0]; DSPNUM_1in9_off[12] = digit_bytes[A_decimal][1]; // 设置数字 B DSPNUM_1in9_off[5] = digit_bytes[B_tens][0]; DSPNUM_1in9_off[6] = digit_bytes[B_tens][1]; DSPNUM_1in9_off[7] = digit_bytes[B_units][0]; DSPNUM_1in9_off[8] = digit_bytes[B_units][1]; DSPNUM_1in9_off[9] = digit_bytes[B_decimal][0]; DSPNUM_1in9_off[10] = digit_bytes[B_decimal][1];&#125;int main() &#123; double A = 23.8; double B = 54.9; // 更新显示 update_display(A, B); // 打印数组内容以验证 for (int i = 0; i &lt; 16; i++) &#123; printf(&quot;0x%02x &quot;, DSPNUM_1in9_off[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 解释 数字到字节的映射表： digit_bytes 数组包含了每个数字（0 到 9）对应的两个字节的值。 提取数字位： 使用整数除法和取模运算提取 A 和 B 的十位、个位和小数点后一位。 更新显示数组： 使用提取到的数字位将 DSPNUM_1in9_off 数组的相应位置更新为查找表中的字节值。 主函数： 定义 A 和 B 的值，调用 update_display 函数更新显示数组，并打印数组内容以验证。 这样，DSPNUM_1in9_off 数组将根据传入的 A 和 B 值动态更新。 小数点的处理上面已经完整实现了两个数字到数组内的转换，但是转出来没有小数点，根据文档： 所以要在数组的第4，8，10位做些处理 我继续对GPT说 GPT回答： 为了实现这个功能，我们需要将特定数组位置的十六进制数转换为二进制，修改二进制数中的特定位，然后将其转换回十六进制并存储在数组中。 以下是修改后的代码，包括处理 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10]： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;// 定义数字对应的字节数组unsigned char digit_bytes[10][2] = &#123; &#123;0xbf, 0x1f&#125;, // 0 &#123;0x00, 0x1f&#125;, // 1 &#123;0xfd, 0x17&#125;, // 2 &#123;0xf5, 0x1f&#125;, // 3 &#123;0x47, 0x1f&#125;, // 4 &#123;0xf7, 0x1d&#125;, // 5 &#123;0xff, 0x1d&#125;, // 6 &#123;0x21, 0x1f&#125;, // 7 &#123;0xff, 0x1f&#125;, // 8 &#123;0xf7, 0x1f&#125; // 9&#125;;// 定义DSPNUM_1in9_off数组unsigned char DSPNUM_1in9_off[16] = &#123;0&#125;;// 将第六位从右往左数改成1的函数unsigned char set_sixth_bit_to_one(unsigned char value) &#123; return value | (1 &lt;&lt; 5); // 第六位对应的二进制位是 5，从0开始计数&#125;// 更新数组的函数void update_display(double A, double B) &#123; // 提取 A 和 B 的各位数字 int A_tens = (int)(A / 10) % 10; int A_units = (int)A % 10; int A_decimal = (int)(A * 10) % 10; int B_tens = (int)(B / 10) % 10; int B_units = (int)B % 10; int B_decimal = (int)(B * 10) % 10; // 设置数字 A DSPNUM_1in9_off[1] = digit_bytes[A_tens][0]; DSPNUM_1in9_off[2] = digit_bytes[A_tens][1]; DSPNUM_1in9_off[3] = digit_bytes[A_units][0]; DSPNUM_1in9_off[4] = set_sixth_bit_to_one(digit_bytes[A_units][1]); // 修改第六位 DSPNUM_1in9_off[11] = digit_bytes[A_decimal][0]; DSPNUM_1in9_off[12] = digit_bytes[A_decimal][1]; // 设置数字 B DSPNUM_1in9_off[5] = digit_bytes[B_tens][0]; DSPNUM_1in9_off[6] = digit_bytes[B_tens][1]; DSPNUM_1in9_off[7] = digit_bytes[B_units][0]; DSPNUM_1in9_off[8] = set_sixth_bit_to_one(digit_bytes[B_units][1]); // 修改第六位 DSPNUM_1in9_off[9] = digit_bytes[B_decimal][0]; DSPNUM_1in9_off[10] = set_sixth_bit_to_one(digit_bytes[B_decimal][1]); // 修改第六位&#125;int main() &#123; double A = 23.8; double B = 54.9; // 更新显示 update_display(A, B); // 打印数组内容以验证 for (int i = 0; i &lt; 16; i++) &#123; printf(&quot;0x%02x &quot;, DSPNUM_1in9_off[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 解释 函数 set_sixth_bit_to_one: 使用位运算将一个字节的第六位（从右数）设置为 1。 更新 DSPNUM_1in9_off 数组: 按照你的要求更新数字 A 和 B 的各个位数字。 在设置 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10] 时，调用 set_sixth_bit_to_one 函数将其第六位设置为 1。结果运行代码后，DSPNUM_1in9_off 数组将根据 A 和 B 的值动态更新，并且 DSPNUM_1in9_off[4], DSPNUM_1in9_off[8] 和 DSPNUM_1in9_off[10] 的第六位将被设置为 1。 然后我就得到了：这里数字是我手动指定的A=73.6,B=84.9，可以看到小数点，百分号都已经显示出来了 再接入传感器读到的数值，温度计就差不多完工啦： 顺便一提这里的传感器驱动代码也是GPT帮调整的，真是神奇","categories":[{"name":"小板子","slug":"小板子","permalink":"https://winotmk.github.io/categories/%E5%B0%8F%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"rashbeerypi","slug":"rashbeerypi","permalink":"https://winotmk.github.io/tags/rashbeerypi/"},{"name":"嵌入式开发","slug":"嵌入式开发","permalink":"https://winotmk.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"},{"name":"C","slug":"C","permalink":"https://winotmk.github.io/tags/C/"},{"name":"PICO","slug":"PICO","permalink":"https://winotmk.github.io/tags/PICO/"}]},{"title":"软件和网站收集","slug":"240619_软件收集","date":"2024-06-18T16:00:00.000Z","updated":"2024-08-14T08:07:35.991Z","comments":true,"path":"240619_软件收集/","link":"","permalink":"https://winotmk.github.io/240619_%E8%BD%AF%E4%BB%B6%E6%94%B6%E9%9B%86/","excerpt":"收集一些看到的好玩的可能以后会用到的软件/服务，软件类大多可以docker部署不定期更新24.8.6更新 A.网站推荐开源大世界 开源大世界 专注于应用级的开源软件、开源资料的情报收集汇总整理。https://kydsj.vip/doku.php?id=wiki:网站目录#计算机辅助设计+https://kydsj.vip/doku.php?id=wiki:自托管-电子书和综合图书馆系统 很多开源软件项目分享，分类详细品种丰富 linuxserver.io LinuxServer.io 文档之家！我们的目标是确保所有镜像都正确记录所有相关信息，以帮助我们的用户入门。除了每个镜像的单独设置指南外，还有与运行 Docker 容器有关的一般信息和最佳实践 https://docs.linuxserver.io/images/docker-calibre-web/","text":"收集一些看到的好玩的可能以后会用到的软件/服务，软件类大多可以docker部署不定期更新24.8.6更新 A.网站推荐开源大世界 开源大世界 专注于应用级的开源软件、开源资料的情报收集汇总整理。https://kydsj.vip/doku.php?id=wiki:网站目录#计算机辅助设计+https://kydsj.vip/doku.php?id=wiki:自托管-电子书和综合图书馆系统 很多开源软件项目分享，分类详细品种丰富 linuxserver.io LinuxServer.io 文档之家！我们的目标是确保所有镜像都正确记录所有相关信息，以帮助我们的用户入门。除了每个镜像的单独设置指南外，还有与运行 Docker 容器有关的一般信息和最佳实践 https://docs.linuxserver.io/images/docker-calibre-web/ webpagetest.org www.webpagetest.org 感觉是很强的网站性能分析工具 又拍云https://www.upyun.com/ autodlhttps://www.autodl.com/market/list B.影音/文件/资料整理emby 任何设备上的个人媒体将您家里的所有视频、音乐和照片集中到一处从未如此简单。您的个人 Emby 服务器会自动即时转换和流式传输您的媒体，以便在任何设备上播放https://github.com/MediaBrowser/Emby?tab=readme-ov-filehttps://emby.media/ jellyfin jellyfin是一套多媒体应用程序软件套装，旨在组织、管理和共享数字媒体文件https://github.com/jellyfin/jellyfinhttps://jellyfin.org/ calibre Calibre-Web 是一款网络应用程序，它使用有效的Calibre数据库提供简洁直观的界面来浏览、阅读和下载电子书https://github.com/janeczku/calibre-webhttps://calibre-ebook.com/目前自用的docker镜像：https://hub.docker.com/r/johngong/calibre-web Nextcloud Nextcloud是一套用于建立网络硬盘的客户端－服务器软件。其功能与Dropbox相近，但Nextcloud是自由及开放源代码软件，每个人都可以在私人服务器上安装并执行它。与Dropbox等专有服务相比，Nextcloud的开放架构让用户可以利用应用程序的方式在服务器上新增额外的功能，并让用户可以完全掌控自己的资料。https://github.com/nextcloudhttps://nextcloud.com/ Found 高效设计师必备的文件浏览器 Found，一键预览三维模型、序列帧、HDRhttps://www.aalab.com.cn/ C.工具类matomo Matomo 是领先的免费/自由开放分析平台。 Matomo 是一款功能齐全的 PHP MySQL 软件程序，您可以下载并安装在自己的网络服务器上。在五分钟的安装过程结束时，您将获得一个 JavaScript 代码。只需将此标签复制并粘贴到您希望跟踪的网站上，即可实时访问您的分析报告。 Matomo 旨在成为 Google Analytics 的免费软件替代品，目前已在 1,400,000 多个网站上使用。隐私功能已内置https://github.com/matomo-org/matomohttps://matomo.org/ Upverter Upverter 是一个模块化的、基于网络的电子电路设计工具，可以完成所有工作——PCB 设计、原理图、自动布线、3D 预览和按照您的确切规格构建订单——用户不再需要为开源项目付费。https://upverter.com/ manimhttps://www.manim.community/ 可以做出3B1B那样好看的数学动画（可以用来做视频的工具)","categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"}]},{"title":"Linux和docker常用命令","slug":"240619_Linux命令","date":"2024-06-18T16:00:00.000Z","updated":"2024-09-24T06:19:17.600Z","comments":true,"path":"240619_Linux命令/","link":"","permalink":"https://winotmk.github.io/240619_Linux%E5%91%BD%E4%BB%A4/","excerpt":"还是会有很多不常用的命令要来回查，仅记录，绝非完整命令参考 文件操作相关复制目录复制目录dir1和dir1目录下的文件到dir2目录里 1cp -r dir1 dir2 安装lrzsz实现zmodem串口文件传输 12rz 下载Zmodemxz 上传Zmodem windterm下支持直接拖拽文件，但是也要安装lrzsz以支持命令https://www.cnblogs.com/lidabo/p/4780866.html 挂载U盘1fdisk -l 可以看到一块14.84GB的SD卡，位置在/dev/sda1使用 1mount -t vfat /dev/sda1 /mnt 来挂载U盘cd到/mnt即可看到U盘里的文件了，另外可以在/mnt里新建文件夹mkdir xxxxx，再挂载到文件夹里 卸载： 1umount /mnt 打包压缩和解压压缩 1tar -czvf ***.tar.gz 解压 1tar -xzvf ***.tar.gz dockerhttps://yeasy.gitbook.io/docker_practice/container/run 启动docker: 1sudo systemctl start docker 查看已有镜像： 1docker ps -a 启动已终止容器: 1docker container start 运行新的镜像run： 1docker run -it -d --name hexo_debian -p 22:22 -p 4000:4000 -v XXX:/hexo/ hexo_debian:V02 save:把本地镜像打包成tar方便带走 1docker save -o jre8u342_ch.tar jre8u342_ch:latest 自用的docker run: 1docker run -d --name=calibre-web -e PUID=1000 -e PGID=1000 -e TZ=Etc/UTC -e DOCKER_MODS=linuxserver/mods:universal-calibre -p 8083:8083 -v D:\\calibre_test\\config:/config -v D:\\calibre_test\\library:/books --restart unless-stopped lscr.io/linuxserver/calibre-web:latest 1docker run -d --name=calibre -e PUID=1000 -e PGID=1000 -e TZ=Asia/Shanghai -e LC_ALL=zh_CN.UTF-8 -p 8080:8080 -p 8181:8181 -p 8081:8081 -v D:\\calibre_test\\library:/library -v D:\\calibre_test\\config:/config --restart unless-stopped lscr.io/linuxserver/calibre:latest","text":"还是会有很多不常用的命令要来回查，仅记录，绝非完整命令参考 文件操作相关复制目录复制目录dir1和dir1目录下的文件到dir2目录里 1cp -r dir1 dir2 安装lrzsz实现zmodem串口文件传输 12rz 下载Zmodemxz 上传Zmodem windterm下支持直接拖拽文件，但是也要安装lrzsz以支持命令https://www.cnblogs.com/lidabo/p/4780866.html 挂载U盘1fdisk -l 可以看到一块14.84GB的SD卡，位置在/dev/sda1使用 1mount -t vfat /dev/sda1 /mnt 来挂载U盘cd到/mnt即可看到U盘里的文件了，另外可以在/mnt里新建文件夹mkdir xxxxx，再挂载到文件夹里 卸载： 1umount /mnt 打包压缩和解压压缩 1tar -czvf ***.tar.gz 解压 1tar -xzvf ***.tar.gz dockerhttps://yeasy.gitbook.io/docker_practice/container/run 启动docker: 1sudo systemctl start docker 查看已有镜像： 1docker ps -a 启动已终止容器: 1docker container start 运行新的镜像run： 1docker run -it -d --name hexo_debian -p 22:22 -p 4000:4000 -v XXX:/hexo/ hexo_debian:V02 save:把本地镜像打包成tar方便带走 1docker save -o jre8u342_ch.tar jre8u342_ch:latest 自用的docker run: 1docker run -d --name=calibre-web -e PUID=1000 -e PGID=1000 -e TZ=Etc/UTC -e DOCKER_MODS=linuxserver/mods:universal-calibre -p 8083:8083 -v D:\\calibre_test\\config:/config -v D:\\calibre_test\\library:/books --restart unless-stopped lscr.io/linuxserver/calibre-web:latest 1docker run -d --name=calibre -e PUID=1000 -e PGID=1000 -e TZ=Asia/Shanghai -e LC_ALL=zh_CN.UTF-8 -p 8080:8080 -p 8181:8181 -p 8081:8081 -v D:\\calibre_test\\library:/library -v D:\\calibre_test\\config:/config --restart unless-stopped lscr.io/linuxserver/calibre:latest docker compose启动组docker compose -f hexo_debian_DockerCompose.yml up -d 关闭组docker compose -f hexo_debian_DockerCompose.yml down -v进入docker容器 1docker exec -it XXX /bin/bash 退出容器但保留按ctrl+P+Q也可以直接接要在容器里执行的命令 1docker exec hexo hexo g -d 拷贝容器内的文件出来，在宿主机上输入： 1docker cp -a vsftpd:/etc/services /root/ screen12345678910111213141516# 创建一个新的窗口screen -S test # 进入窗口后 执行文件python test.py # 退出当前窗口ctrl+a+d （方法1：保留当前窗口）screen -d （方法2：保留当前窗口）exit （方法3：退出程序，并关闭窗口） # 查看窗口screen -ls # 重新连接窗口screen -r id或窗口名称","categories":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"}]},{"title":"地理数据采集器计划","slug":"240617_地理数据采集器计划","date":"2024-06-16T16:00:00.000Z","updated":"2024-07-19T04:30:02.631Z","comments":true,"path":"240617_地理数据采集器计划/","link":"","permalink":"https://winotmk.github.io/240617_%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%99%A8%E8%AE%A1%E5%88%92/","excerpt":"简介想要做一个便携的小设备，能够实现以下功能 记录当前地点的气压，温度，湿度等地理信息 记录GPS坐标信息 考虑加上摄像头记录当前周围视觉环境，同时可以将上述信息水印（字幕)在照片上 存储所有记录的数据以便之后进行可视化数据生成，可以用类似XML，Json，或者找有没有嵌入式轻量数据库实现 它最好有以下这样的特点： 手机一般大小可以塞进口袋 一定程度的防摔防水外壳 续航可以接受2-3天一充电 所以我的打算用现有的能买到的小板子和单片机来做，预算不是大问题，大概1500-2000，（包含试错和学习成本）考虑过几种方向： ESP32 树莓派PICO 幸狐的板子和摄像头 树莓派Zero最后发现现在目前树莓派zero2w的价格只有一百出头了，可能比某些arduino的原版板子还便宜，值得一试，幸狐看起来也不错的样子，回头再研究 下面这是树莓派zero2w跑通串口通信时的样子","text":"简介想要做一个便携的小设备，能够实现以下功能 记录当前地点的气压，温度，湿度等地理信息 记录GPS坐标信息 考虑加上摄像头记录当前周围视觉环境，同时可以将上述信息水印（字幕)在照片上 存储所有记录的数据以便之后进行可视化数据生成，可以用类似XML，Json，或者找有没有嵌入式轻量数据库实现 它最好有以下这样的特点： 手机一般大小可以塞进口袋 一定程度的防摔防水外壳 续航可以接受2-3天一充电 所以我的打算用现有的能买到的小板子和单片机来做，预算不是大问题，大概1500-2000，（包含试错和学习成本）考虑过几种方向： ESP32 树莓派PICO 幸狐的板子和摄像头 树莓派Zero最后发现现在目前树莓派zero2w的价格只有一百出头了，可能比某些arduino的原版板子还便宜，值得一试，幸狐看起来也不错的样子，回头再研究 下面这是树莓派zero2w跑通串口通信时的样子 这个网站不错：https://pinout.xyz/ 可知右上这几个接口就可以实现TTL的UART连接了，我尝试ground是要接的 资料FT232串口工具https://www.waveshare.net/wiki/FT232_USB_UART_Board GPS模块https://www.waveshare.net/wiki/LC76G_GPS_Module在准备安装micropyGPS时提示No module namd setuptools怀疑需要执行apt-get install python3-setuptools可惜目前没有网络环境，回家尝试了 Raspberry Zero 2Whttps://www.waveshare.net/wiki/Raspberry_Pi_Zero_2_W UPS 模块https://www.waveshare.net/wiki/UPS_HAT_(C) 环境传感器https://www.waveshare.net/shop/Environment-Sensor-HAT.htm 项目/软件数据可视化相关很不错的开源教程Data-Science-For-Beginnershttps://microsoft.github.io/Data-Science-For-Beginners/#/ Matplotlibhttps://matplotlib.org/stable/index.htmlMatplotlib是一个出色的库，可用于创建各种简单和复杂的图表https://microsoft.github.io/Data-Science-For-Beginners/#/3-Data-Visualization/09-visualization-quantities/README Streamlithttps://github.com/streamlit/streamlit更偏向于python库直接生成web，同时也有很多数据可视化的内容，更实用？便于展示 powerbihttps://www.microsoft.com/en-us/power-platform/products/power-bi似乎是微软的web数据可视化绘图 GPXSee配合gps数据收集可以展示出来https://github.com/tumic0/GPXSee 图形库LVGLhttps://lvgl.100ask.net/master/get-started/index.htmlhttps://github.com/lvgl/lvgl SquareLine Studio UI - 配合上面的LVGL用https://squareline.io/https://www.bilibili.com/video/BV1DX4y1v727/?vd_source=b7b7bdf106a064893c3c79e4a961f383 guiguider 同上类别但免费https://www.bilibili.com/video/BV1yW421R7zK/?spm_id_from=333.788.recommend_more_video.7&amp;vd_source=b7b7bdf106a064893c3c79e4a961f383 figmaUI前期设计软件 UI 框架：oled-ui-astrahttps://github.com/AstraThreshold/oled-ui-astrahttps://www.bilibili.com/video/BV1i4421D7nJ/?vd_source=b7b7bdf106a064893c3c79e4a961f383","categories":[{"name":"小板子","slug":"小板子","permalink":"https://winotmk.github.io/categories/%E5%B0%8F%E6%9D%BF%E5%AD%90/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"rashbeerypi","slug":"rashbeerypi","permalink":"https://winotmk.github.io/tags/rashbeerypi/"},{"name":"嵌入式开发","slug":"嵌入式开发","permalink":"https://winotmk.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"}]},{"title":"令人头疼的vsftpd,ftp端口修改设置配置","slug":"240617_令人头疼的vsftpd","date":"2024-06-16T16:00:00.000Z","updated":"2024-06-21T03:51:00.429Z","comments":true,"path":"240617_令人头疼的vsftpd/","link":"","permalink":"https://winotmk.github.io/240617_%E4%BB%A4%E4%BA%BA%E5%A4%B4%E7%96%BC%E7%9A%84vsftpd/","excerpt":"","text":"这么个小小的软件花费了不成正比的时间去弄他，十分令人头疼，简单记录几点重要的设置 1vim /etc/vsftpd.conf vsftpd 配置文件：https://gnu-linux.readthedocs.io/zh/latest/Chapter02/90_vsftpd.html 修改ftp的端口ftp的监听和实际数据传输是两个端口，如果要改最好都改 123connect_from_port_20=NOftp_data_port=12520listen_port=12521 pasv模式时的端口范围设置，假如用docker运行这些端口都要转出来 123pasv_promiscuous=YESpasv_min_port=31100pasv_max_port=31110 我至今没太搞明白ftp的主动与被动模式的区别，以及能不能只用其中一种模式来工作.. 另外还有系统的services里 123456vim /etc/services#ftp-data 20/tcp#ftp-data 20/udpftp-data 12520/tcpftp-data 12520/udp 这个不确定是否必要但还是改了吧 中文乱码 一篇不错的配置说明https://blog.starryvoid.com/archives/1044.html主要提到了utf8的编码问题 utf8_filesystem=YES 如果这样还没解决，考虑是要修改容器本身的LANG可以直接进入容器然后类似：export LANG=C.UTF-8或者export LANG=en_US.UTF-8输入locale查看结果当然这样关了这个sh就没了，所以可以直接加到docker启动时的环境变量里https://zihengcat.github.io/2018/09/10/change-locale-system-encoding-in-docker-container/然后你猜怎么着，做完这些设置以后中文依然显示为乱码，但是在FileZilla里看却没问题 现在高度怀疑是VScode的这个SFTP同步插件的锅","categories":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"ftp","slug":"ftp","permalink":"https://winotmk.github.io/tags/ftp/"}]},{"title":"StableDiffusion大模型(Dreambooth)云上训练以及安装CODA指定版本","slug":"240110_SD大模型云上训练","date":"2024-01-10T16:00:00.000Z","updated":"2024-01-11T06:50:21.847Z","comments":true,"path":"240110_SD大模型云上训练/","link":"","permalink":"https://winotmk.github.io/240110_SD%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%BA%91%E4%B8%8A%E8%AE%AD%E7%BB%83/","excerpt":"创建阿里云PAI DSW实例跑kohya镜像我这里选：dsw-registry-vpc.cn-shanghai.cr.aliyuncs.com/pai/modelscope:1.10.0-pytorch2.1.0tensorflow2.14.0-gpu-py310-cu118-ubuntu22.04我这里用默认的镜像，实测截至2024.01.10时，直接拉kohya的github可以直接用，不需要改动cuda之类的操作 安装kohya_sskohya_ss仓库地址：https://github.com/bmaltais/kohya_sskohya_ss是个webui训练器，SD web_ui里也有对应的Dreambooth训练插件移植，如果只拿来训练不需要跑完整的sd webui服务，只需要kohya就可以了,kohay也可以练lora在workspace根目录直接： 1git clone https://github.com/bmaltais/kohya_ss.git","text":"创建阿里云PAI DSW实例跑kohya镜像我这里选：dsw-registry-vpc.cn-shanghai.cr.aliyuncs.com/pai/modelscope:1.10.0-pytorch2.1.0tensorflow2.14.0-gpu-py310-cu118-ubuntu22.04我这里用默认的镜像，实测截至2024.01.10时，直接拉kohya的github可以直接用，不需要改动cuda之类的操作 安装kohya_sskohya_ss仓库地址：https://github.com/bmaltais/kohya_sskohya_ss是个webui训练器，SD web_ui里也有对应的Dreambooth训练插件移植，如果只拿来训练不需要跑完整的sd webui服务，只需要kohya就可以了,kohay也可以练lora在workspace根目录直接： 1git clone https://github.com/bmaltais/kohya_ss.git 很快就能完成，接着依次执行 1234cd ./kohya_ssapt update -y &amp;&amp; apt install -y python3-tkchmod +x ./setup.sh./setup.sh 虽然镜像里带py310，但是似乎还是要装一下python3-tk之后安装脚本会自动完成，我大概花了5分钟然后运行启动webui 1HF_ENDPOINT=https://hf-mirror.com ./gui.sh --headless 点击这个本地的IP即能点开webui了HF_ENDPOINT=https://hf-mirror.com是为了防止抱脸会更新卡住而用的镜像网站（我确实因为这个卡过）或者见本站另一篇专门说代理的文章：https://winotmk.github.io/240109_Linux%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/ kohya_ss的Dreambooth训练参数source model我这里用自己上传的模型，可以先上传至阿里云oss再挂载进来，所以这里这样选，然后填模型路径就好了 floders这个tag里比较简单，没什么好说的Image folder里写上训练集目录，注意写上的目录底下应该是例如10_ABC目录，然后再放图和txt文件，这个10就step的10，和lora训练时候一样 parameters basic和lora训练设置大同小异，但是参数要比lora小得多，因为Dreambooth比lora性能消耗要大得多而且非常容易过拟合，图出来一滩浆糊，比如我尝试epoch可能10以内就足够，由于文件比较大Save every N epochs我一般也就3-4，其他参数看个人需求吧 samples这里能填关键词和每多少轮出个预览图，玩玩用都准备好了就可以点 start training，但webui不会有任何提示..要看之前启webui的终端这样就是开始训练了：不过我第一次成功启动了webui但是点开始训练以后，报过类似这样的错： 12345678910111213141516171819202122232425262728293031323334353637383940414243The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;/usr/local/nvidia/lib64&#x27;), PosixPath(&#x27;/usr/local/nvidia/lib&#x27;)&#125;/usr/local/lib/python3.10/dist-packages/bitsandbytes/cuda_setup/main.py:166: UserWarning: /usr/local/nvidia/lib:/usr/local/nvidia/lib64:/usr/local/cuda-11 did not contain [&#x27;libcudart.so&#x27;, &#x27;libcudart.so.11.0&#x27;, &#x27;libcudart.so.12.0&#x27;] as expected! Searching further paths... warn(msg)The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;//license-pai.cn-shanghai.data.aliyun.com&#x27;), PosixPath(&#x27;http&#x27;)&#125;The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;dsw-registry-vpc.cn-shanghai.cr.aliyuncs.com/cloud-dsw/eas-service&#x27;), PosixPath(&#x27;aigc-torch113-cu117-ubuntu22.04-v0.2.1&#x27;)&#125;The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;http&#x27;), PosixPath(&#x27;8088/dsw-301739&#x27;), PosixPath(&#x27;//127.0.0.1&#x27;)&#125;The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;Asia/Shanghai&#x27;)&#125;The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;tcp&#x27;), PosixPath(&#x27;443&#x27;), PosixPath(&#x27;//10.192.0.1&#x27;)&#125;The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;https&#x27;), PosixPath(&#x27;//dsw-cn-shanghai.data.aliyun.com&#x27;)&#125;The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;tcp&#x27;), PosixPath(&#x27;443&#x27;), PosixPath(&#x27;//10.192.0.1&#x27;)&#125;The following directories listed in your path were found to be non-existent: &#123;PosixPath(&#x27;/home/pai/bin/python&#x27;)&#125;CUDA_SETUP: WARNING! libcudart.so not found in any environmental path. Searching in backup paths...DEBUG: Possible options found for libcudart.so: &#123;PosixPath(&#x27;/usr/local/cuda/lib64/libcudart.so.11.0&#x27;)&#125;CUDA SETUP: PyTorch settings found: CUDA_VERSION=118, Highest Compute Capability: 7.0.CUDA SETUP: To manually override the PyTorch CUDA version please see:https://github.com/TimDettmers/bitsandbytes/blob/main/how_to_use_nonpytorch_cuda.md/usr/local/lib/python3.10/dist-packages/bitsandbytes/cuda_setup/main.py:166: UserWarning: WARNING: Compute capability &lt; 7.5 detected! Only slow 8-bit matmul is supported for your GPU! If you run into issues with 8-bit matmul, you can try 4-bit quantization: https://huggingface.co/blog/4bit-transformers-bitsandbytes warn(msg)CUDA SETUP: Loading binary /usr/local/lib/python3.10/dist-packages/bitsandbytes/libbitsandbytes_cuda118_nocublaslt.so...libcusparse.so.11: cannot open shared object file: No such file or directoryCUDA SETUP: Something unexpected happened. Please compile from source:git clone https://github.com/TimDettmers/bitsandbytes.gitcd bitsandbytesCUDA_VERSION=118 make cuda11x_nomatmulpython setup.py installTraceback (most recent call last): File &quot;/usr/lib/python3.10/runpy.py&quot;, line 187, in _run_module_as_main mod_name, mod_spec, code = _get_module_details(mod_name, _Error) File &quot;/usr/lib/python3.10/runpy.py&quot;, line 146, in _get_module_details return _get_module_details(pkg_main_name, error) File &quot;/usr/lib/python3.10/runpy.py&quot;, line 110, in _get_module_details __import__(pkg_name) File &quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/__init__.py&quot;, line 6, in &lt;module&gt; from . import cuda_setup, utils, research File &quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/research/__init__.py&quot;, line 1, in &lt;module&gt; from . import nn File &quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/research/nn/__init__.py&quot;, line 1, in &lt;module&gt; from .modules import LinearFP8Mixed, LinearFP8Global File &quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/research/nn/modules.py&quot;, line 8, in &lt;module&gt; from bitsandbytes.optim import GlobalOptimManager File &quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/optim/__init__.py&quot;, line 6, in &lt;module&gt; from bitsandbytes.cextension import COMPILED_WITH_CUDA File &quot;/usr/local/lib/python3.10/dist-packages/bitsandbytes/cextension.py&quot;, line 20, in &lt;module&gt; raise RuntimeError(&#x27;&#x27;&#x27; 以及如果遇到类似： 1Could not load dynamic library &#x27;libcudart.so.11.0&#x27; 重新装适合的CUDA版本即可解决，如果要装CUDA： CUDA相关安装CUDA指定版本遇到过cuda版本不匹配的问题，记一下配置过程cuda下载：https://developer.nvidia.com/cuda-downloads但是有时候需要特定版本：https://developer.nvidia.com/cuda-toolkit-archive以11.8为例，系统是ubuntu22.04，所以这样选：下载安装cuda： 123cd /mnt/workspacewget https://developer.download.nvidia.com/compute/cuda/11.8.0/local_installers/cuda_11.8.0_520.61.05_linux.runsudo sh cuda_11.8.0_520.61.05_linux.run 大约3-4GB左右，运行后需要等一会，会弹出交互界面这里去掉安装驱动，因为我们已经有驱动了只是想要不同版本的cuda，然后选安装 ps如果遇到装了多份驱动需要卸一个的情况：https://www.jianshu.com/p/54928967e417 装好以后他会提示：需要往 LD_LIBRARY_PATH 和 PATH 里添加两条环境变量 12export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.8/lib64export PATH=$PATH:/usr/local/cuda-11.8/bin 之后我使用 1python -m bitsandbytes 如果没有报错应该就是好用的 ps如果是windows上的wsl： 1export LD_LIBRARY_PATH=/usr/lib/wsl/lib/ 切换cuda版本12export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.7export BNB_CUDA_VERSION=117 改环境变量可以手动切换版本（当然得已经装了) 查看cuda版本1nvidia-smi 或者可以：参考：https://blog.csdn.net/Kefenggewu_/article/details/117675079默认cuda会装在/usr/local,所以查看安装版本可以这样： 1ls -l /usr/local | grep cuda 或者据说可以nvcc -V # (V大写) 本节另外的参考：https://github.com/TimDettmers/bitsandbytes/blob/main/how_to_use_nonpytorch_cuda.md 链接kohya_ss:https://github.com/bmaltais/kohya_ss一个封装好的kohya-docker的镜像https://github.com/ashleykleynhans/kohya-docker dreambooth相关介绍：https://huggingface.co/docs/diffusers/training/dreamboothhttps://github.com/google/dreambooth","categories":[{"name":"stable diffusion","slug":"stable-diffusion","permalink":"https://winotmk.github.io/categories/stable-diffusion/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"阿里云","slug":"阿里云","permalink":"https://winotmk.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"AI","slug":"AI","permalink":"https://winotmk.github.io/tags/AI/"},{"name":"stable diffusion","slug":"stable-diffusion","permalink":"https://winotmk.github.io/tags/stable-diffusion/"}]},{"title":"Linux上的命令行代理工具","slug":"240109_Linux上的命令行代理工具","date":"2024-01-08T16:00:00.000Z","updated":"2024-01-09T08:02:03.585Z","comments":true,"path":"240109_Linux上的命令行代理工具/","link":"","permalink":"https://winotmk.github.io/240109_Linux%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/","excerpt":"阿里云的AI白票试用还是很香的，b站顺便一搜有很多教程，跑个lora训练或者SD webui之类的但难免会遇到要拉更新之类的情况，github和huggingface.co速度慢或者连不上去也经常遇到，除了使用镜像站以外，还有可以使用代理来加速 先通SOCKS5！安装ss先贴上需要用到的软件github：https://github.com/shadowsocks/shadowsocks-libev 以及大概解释了什么是ss2，ss-go，ss-libevhttps://shadowsocks5.github.io/en/spec/Implementations.html 在云端实例命令行下，需要个尽可能简洁小巧又好用的工具，ss-libev可能会是我们的首选，ss-libev是一个轻量级安全 SOCKS5 代理，适用于嵌入式设备和低端设备，用纯 C 编写，体积小巧比较高效我的云计算镜像是基于ubuntu22.04的要安装它，直接 12sudo apt updatesudo apt install shadowsocks-libev 配置ss然后编辑设置： 12# Edit the configuration filesudo vim /etc/shadowsocks-libev/config.json","text":"阿里云的AI白票试用还是很香的，b站顺便一搜有很多教程，跑个lora训练或者SD webui之类的但难免会遇到要拉更新之类的情况，github和huggingface.co速度慢或者连不上去也经常遇到，除了使用镜像站以外，还有可以使用代理来加速 先通SOCKS5！安装ss先贴上需要用到的软件github：https://github.com/shadowsocks/shadowsocks-libev 以及大概解释了什么是ss2，ss-go，ss-libevhttps://shadowsocks5.github.io/en/spec/Implementations.html 在云端实例命令行下，需要个尽可能简洁小巧又好用的工具，ss-libev可能会是我们的首选，ss-libev是一个轻量级安全 SOCKS5 代理，适用于嵌入式设备和低端设备，用纯 C 编写，体积小巧比较高效我的云计算镜像是基于ubuntu22.04的要安装它，直接 12sudo apt updatesudo apt install shadowsocks-libev 配置ss然后编辑设置： 12# Edit the configuration filesudo vim /etc/shadowsocks-libev/config.json 在config.json里 123456789&#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;mode&quot;:&quot;tcp_and_udp&quot;, &quot;server_port&quot;:8388, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;barfoo!&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;&#125; server :您的主机名或服务器 IP (IPv4/IPv6) mode :模式一般不动 server_port :服务器端口号 local_port :本地端口号，一般默认就1080 password :密码 timeout :连接超时（以秒为单位） method :加密算法 这些信息只要你找的代理供应商支持ss协议应该都可以拿到 ps顺便给同学们复习下vim，懒得用vim的可以不看，按a进入编辑模式，方向键移动光标，编辑完成后按两下 ctrl+c 进入指令模式然后:wq!保存更改并退出,如果直接退出不保存是:q! 启动ss客户端任意目录输入 1ss-local 即可做为客户端启动这里我启动成功以后显示： ps这个软件可以以服务端启动，同样也是修改上面的etc/shadowsocks-libev/config.json,这里挺容易混淆啊，我这里的目标是想给我的云上GPU计算实例代理加速，所以以客户端启动就行如果要以服务端启动 1systemctl start shadowsocks-libev.service systemctl如果云上镜像里没有（大概率没有，容器镜像谁会带systemctl或者systemd呢~），可以尝试 1sudo /etc/init.d/shadowsocks-libev start 安装proxychains使软件走代理上面只做到了客户端使用SOCKS5打通代理，接下来再用另外一个软件使我们指定的命令/app走这条SOCKS5线路，也就是需要个SOCKS5转HTTP的工具来为我们所用这里发现了proxychains ProxyChains 是一个强制应用的 TCP 连接通过代理的工具，支持 Tor、HTTP、与 Socks 代理。ProxyChains 只会将当前应用的 TCP 连接转发至代理，而非全局代理。 安装proxychains1sudo apt install proxychains 超快就安装好了 配置1vim /etc/proxychains.conf 12345678[ProxyList]# add proxy here ...# meanwile# defaults set to &quot;tor&quot;#socks4 127.0.0.1 9050# examplesocks5 127.0.0.1 1080 使用ProxyChains 的使用方式非常简单，直接在应用程序前加上 proxychains 即可例如： 1proxychains git clone https://github.com/rofl0r/proxychains-ng 但是据说ping是不行的，因为pin并不是TCP而是ICMP，所以可以尝试proxychains ping google.com,总之我是能解析出IP但是会卡住ping不了，问题不大 试试看是不是通了：先试试 1curl cip.cc 得到 我们加上proxychains以后 1proxychains curl cip.cc 看！效果立竿见影，而且可以灵活使用 另外一种方法或许可以不装proxychains直接设置变量 12export http_proxy=&quot;socks5://127.0.0.1:1080&quot;export https_proxy=&quot;socks5://127.0.0.1:1080&quot; 可能也可以但没试过 其他一些镜像方案：huggingface运行python时前加HF_ENDPOINT=https://hf-mirror.com，这样就可以实现后续走镜像加速了 1HF_ENDPOINT=https://hf-mirror.com python your_script.py 详细用法：https://hf-mirror.com/ github示例用法，直接github域名前加https://mirror.ghproxy.com/ 1https://mirror.ghproxy.com/https://github.com/d8ahazard/sd_dreambooth_extension 详细见：https://mirror.ghproxy.com/有些部署文件里还是用的之前的域名https://ghproxy.com/,已失效，改用二级域名https://mirror.ghproxy.com/即可 附录本文参考文章linux命令行代理神器-proxychainshttps://zhuanlan.zhihu.com/p/166375631 Linux 让终端走代理的几种方法https://zhuanlan.zhihu.com/p/46973701 ss服务端和客户端安装https://mkmerich.com/2018-09-23/shadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E8%A3%85.html 基本概念,什么是ss什么是socks5https://reezon.github.io/2018/05/23/%E5%85%B3%E4%BA%8Ess(%E9%85%B8%E9%85%B8)%E5%92%8Cssr(%E9%85%B8%E9%85%B8%E4%B9%B3)%EF%BC%8C%E8%BF%98%E6%9C%89vpn%E5%92%8Csocks5/ 使用Curl时可以直接用socks5https://blog.emacsos.com/use-socks5-proxy-in-curl.html 其他类似方案软件sshuttlehttps://github.com/sshuttle/sshuttle yuhaiinhttps://github.com/yuhaiin/yuhaiin clash-vergehttps://github.com/zzzgydi/clash-verge","categories":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"proxy","slug":"proxy","permalink":"https://winotmk.github.io/tags/proxy/"}]},{"title":"群晖上用容器搭建SVN服务器","slug":"群晖上搭建SVN服务器","date":"2023-12-13T16:00:00.000Z","updated":"2023-12-14T10:40:59.871Z","comments":true,"path":"群晖上搭建SVN服务器/","link":"","permalink":"https://winotmk.github.io/%E7%BE%A4%E6%99%96%E4%B8%8A%E6%90%AD%E5%BB%BASVN%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"事先：我是用路由拨号所以家里已经有外网直连IP，且配置了DDNS和端口转发，所以一个域名即可连上NAS另外我的群晖是DS720+，是块X86intel的CPU，所以和PC一样用X86的容器镜像就可以，如果是ARM机NAS应该是不通用的 所用镜像：https://hub.docker.com/r/garethflowers/svn-server备选镜像（看起来也很不错，拉取次数也过1M：https://hub.docker.com/r/elleflorio/svn-server SVN网站：https://subversion.apache.org/ 参考：https://blog.51cto.com/u_12701820/6544028 准备镜像由于在群晖的ContainerManager里直接添加镜像不能，应该是要配个docker的镜像站加速或者整个NAS在梯子环境里，懒得整了，我这次选择PC上保存镜像包再拖来NAS里用的形式，个人感觉更方便些 先在PC上拉个镜像，直接 1docker pull garethflowers/svn-server:latest 然后把镜像打包成文件 1docker save -o svn-server.tar garethflowers/svn-server:latest","text":"事先：我是用路由拨号所以家里已经有外网直连IP，且配置了DDNS和端口转发，所以一个域名即可连上NAS另外我的群晖是DS720+，是块X86intel的CPU，所以和PC一样用X86的容器镜像就可以，如果是ARM机NAS应该是不通用的 所用镜像：https://hub.docker.com/r/garethflowers/svn-server备选镜像（看起来也很不错，拉取次数也过1M：https://hub.docker.com/r/elleflorio/svn-server SVN网站：https://subversion.apache.org/ 参考：https://blog.51cto.com/u_12701820/6544028 准备镜像由于在群晖的ContainerManager里直接添加镜像不能，应该是要配个docker的镜像站加速或者整个NAS在梯子环境里，懒得整了，我这次选择PC上保存镜像包再拖来NAS里用的形式，个人感觉更方便些 先在PC上拉个镜像，直接 1docker pull garethflowers/svn-server:latest 然后把镜像打包成文件 1docker save -o svn-server.tar garethflowers/svn-server:latest 就能得到一个svn-server.tar的文件了，把这个文件上传到ContainerManager里 然后左边的TAG里选容器》新增，选择刚上传的svn-server 配置镜像镜像用法说明，基本上配置个端口和映射库就行/SVN_library/SVN_Folder是我专门创建的新的NAS文件夹 之后下一步容器就能启动起来了 打开终端机》通过命令启动》用/bin/sh 来开一个交互的shell然后我输入 1svnadmin create WinSVN 来建我的第一个SVN仓库名为WinSVN （以下部分参考: https://cloud.tencent.com/developer/article/1650131 然后找到/SVN_library/SVN_Folder/WinSVN/conf，里面是SVN的配置文件了编辑svnserve.conf anon-access = none #取消匿名访问auth-access = write #授权用户有可写权限password-db = passwd #指定用户配置文件，后面会用到 编辑passwd添加了自己的账户，至于分区权限我暂时用不到 记得重启容器，服务器部分好像就差不多了 最后别忘记路由器上配个3690端口转发来远程访问这个仓库，我用的是ikuai的路由OS 测试连接pc端新建个文件夹，右键SVN CheckOut地址可以输入svn://DDNS的域名:3690/WinSVN，输入上面passwd文件里设置好的用户名和密码就好了！！ 之后就是svn客户端的基本用法了，随便放一个文件尝试上传很快就传好了，至此这个SVN仓库宣告可用！","categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"},{"name":"NAS","slug":"NAS","permalink":"https://winotmk.github.io/tags/NAS/"},{"name":"SVN","slug":"SVN","permalink":"https://winotmk.github.io/tags/SVN/"}]},{"title":"WinNote","slug":"WinNote","date":"2023-12-12T16:00:00.000Z","updated":"2024-06-17T09:37:50.928Z","comments":true,"path":"WinNote/","link":"","permalink":"https://winotmk.github.io/WinNote/","excerpt":"","text":"一个轻量级MD文档收集博客，不保证阅读性使用树莓派+hexo构建，定制化next主题，github部署2023.9.8更新使用eci容器构建，自制镜像，cdn加速 一些编辑的Tips:首页文章预览至： 1&lt;!-- more --&gt; markdown paste粘图： 1ctrl+art+a 本站加速域名：https://md.winotmk.com/正式站：winotmk.com 2023.12.13更新为了防止忘记如何写这个博客，特留备忘NAS上工作台的盘符请设置为T启动ecistarter容器然后CD ecistart 进入目录使用. ./hexo_s 来脚本启动阿里云eci上的容器，此脚本包含如果一段时间内没有连接将会自动释放掉eci容器的功能，判断依据是是否有SSH接入之后通过VSCode的插件SSH FS来接入md文档的目录是./hexo/Winblog/source/_posts 关于图片插入：本地目录T:\\博客\\md_for_hexo\\Images将会与FTP上的./hexo/Winblog/source/images自动单向同步 2024.06.17再更新因为买了阿里99服务器，改用了容器的形式运行启动组docker compose -f hexo_debian_DockerCompose.yml up -d 关闭组docker compose -f hexo_debian_DockerCompose.yml down -v同时配置了本地文章目录T:\\博客\\md_for_hexo_workspace和FTP上的./hexo/Winblog/source/_posts自动同步，终于不会存在本地和服务器上两份文章了在md_for_hexo_workspace写好后直接docker exec hexo hexo g -d即可发布","categories":[],"tags":[{"name":"WinNote","slug":"WinNote","permalink":"https://winotmk.github.io/tags/WinNote/"}]},{"title":"Docker01.1_eci价格计算表","slug":"Docker01.1_价格计算表","date":"2023-08-24T16:00:00.000Z","updated":"2023-09-08T08:04:00.378Z","comments":true,"path":"Docker01.1_价格计算表/","link":"","permalink":"https://winotmk.github.io/Docker01.1_%E4%BB%B7%E6%A0%BC%E8%AE%A1%E7%AE%97%E8%A1%A8/","excerpt":"","text":"计费文档：https://help.aliyun.com/document_detail/447697.html 定价标准： vCPU单价（vCPU）：0.000049 元/秒内存单价（GiB）： 0.00000613 元/秒 所以可知： 规格 秒 分钟 小时 天 月 年 每1u 0.00004900 0.00294 0.1764 4.2336 127.008 1545.264 每1G内存 0.00000613 0.0003678 0.022068 0.529632 15.88896 193.31568 eci价格计算： 实例规格 秒 分钟 小时 天 月 年 0.25u 0.5G 0.00001532 0.0009189 0.055134 1.323216 39.69648 482.97384 0.5u 1G 0.00003063 0.0018378 0.110268 2.646432 79.39296 965.94768 2u 4G 0.00012252 0.0073512 0.441072 10.585728 317.57184 3863.79072 2u 8G 0.00014704 0.0088224 0.529344 12.704256 381.12768 4637.05344 4u 8G 0.00024504 0.0147024 0.882144 21.171456 635.14368 7727.58144 64u 256G 0.00470528 0.2823168 16.939008 406.536192 12196.08576 148385.7101 一秒0.0047元很便宜吗？一月要1.2w！可以说被安排得明明白白了","categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"}],"tags":[{"name":"阿里云","slug":"阿里云","permalink":"https://winotmk.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"eci","slug":"eci","permalink":"https://winotmk.github.io/tags/eci/"}]},{"title":"Docker01_用docker构建hexo和vsftpd与ddns镜像并且用阿里云容器服务ECI运行","slug":"Docker01","date":"2023-08-04T16:00:00.000Z","updated":"2023-09-08T11:11:50.682Z","comments":true,"path":"Docker01/","link":"","permalink":"https://winotmk.github.io/Docker01/","excerpt":".nav-number { display:none !important; } .post-toc .nav-item { white-space: normal !important; } 一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的 了解ECI弹性容器：https://www.aliyun.com/product/eci了解阿里云NAS文件存储：https://www.aliyun.com/product/nas 为什么要用eci来运行hexo？因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种本博客之前是由树莓派上的hexo生成，部署到github上的最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了）恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的最后成品的结构大致如下图： 这里挂了3个镜像：1.node.js+git+ssh+hexo主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会hexo g -d，而运行这套需要一个环境容器git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理2.vsftpd一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！3.ddns因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像 还挂了一个NAS盘：挂载以后：可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计 文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用","text":".nav-number { display:none !important; } .post-toc .nav-item { white-space: normal !important; } 一口气步子迈得有大，慢慢记录一下,如果你碰巧看到这个文章，希望这个文章的某些部分对你有帮助，来源我已尽量在文章中标出，还有很多部分是自己敲的 了解ECI弹性容器：https://www.aliyun.com/product/eci了解阿里云NAS文件存储：https://www.aliyun.com/product/nas 为什么要用eci来运行hexo？因为好玩，同时来学习从pull到发布到运行整个docker镜像的流程，也想给自己的hexo博客找个新家，酷酷的那种本博客之前是由树莓派上的hexo生成，部署到github上的最近在捣鼓docker，一时想不起来有什么灵活小巧的服务拿来用docker玩，那么想着干脆把树莓派上hexo这部分服务做成镜像，需要用的时候拿出来用用想必是极好的（这么一来好像树莓派又要吃灰了）恰巧最近又在琢磨阿里云ECI容器服务，所以理论上是可以用我自己打包好的镜像的最后成品的结构大致如下图： 这里挂了3个镜像：1.node.js+git+ssh+hexo主要是此镜像——由node.js+hexo组成的运行hexo环境，用过的都了解hexo是基于node.js的，每次我们生成文章的时候都会hexo g -d，而运行这套需要一个环境容器git和ssh主要是部署在github上用的，同时我习惯用VSCode的SSH FS来管理远程文件和写博客，主要是ssh连接，也方便我拿PuTTY和WinSCP远程登录管理2.vsftpd一个常用的ftp服务，我是在本地些完再上传的，用这个是因为我发现如果要给文章插入图片，我还需要手动用ssh上传到hexo对应目录里。而用VSCode的SSH FS可以帮我自动同步本地工作目录和云上即将生成静态网页的hexo目录，非常方便！3.ddns因为容器是即用即开，用完就释放的，每次开会新分配一个弹性IP做为外网接口，但是不想每次都去复制这个新的ip地址，那么就要用到动态域名解析，刚好我在阿里云上购买过一个我自己的域名，所以ddns这部分服务就拉出来做个镜像 还挂了一个NAS盘：挂载以后：可见我的hexo，主题，文章，图片等等都存放在里面，服务容器可以随便释放拉取，数据不会受到影响，几百M的NAS容量价格抹零后可以忽略不计 文章后面（第三部分）会说如何按我的需求构建定制这几个镜像，并上传到阿里云容器镜像ARK仓库以方便调用 vsftpd还有ddns可以与主镜像node.js+hexo合并成一个大镜像吗？当然可以，但我实际做了几次以后发现把ftp，ddns这样常用的服务功能单独拿出来会方便得多的多，毕竟我想起别得服务，也可以给他们挂上ftp等常用服务，我也可以选择不挂，这样容器的优势就体现出来了。我可以把单一的服务都做成单独的小镜像，需要哪个挂哪个，性能消耗也很小 整套下来有这些部分： docker基本操作 已经启动的本地容器修改端口，启动容器时即启动服务等 打包制作自己的docker镜像(dockerfile) docker镜像打包并上传到阿里云镜像库ARK eci容器创建模板和eci命令行工具使用 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档 附表：群晖搭建私有镜像仓库和dockerengine设置eci价格计算表 1. docker 基本操作博主吐槽一下，总觉得一些类似run，commit操作完全可以做成一个美观好用的UI控制软件，但是docker destop就是不做，然后大家都默认敲命令行是方便的，好用的。十分不解，可能需要ui的不会写ui，熟练使用命令行的也不需要什么ui吧，诶——后面随着对docker了解的深入，明白它不是虚拟机，用得还是linux内核，这么一想，处处真是浓浓的linux味，现在能提供一个windows下的Docker Desktop桌面程序，已经非常得不错了！资料网站： 官方命令大全 基于Docker的Hexo博客搭建 这个基本操作写得还行下次爬一篇下来吧： [小抄] Docker 基本命令 1.1 运行容器1docker run -it -d --name [container-name] -p 8088:80 [image-name] 这里是将容器内的80端口映射到宿主机的8088端口 参数说明 -d 表示后台运行容器-t 为docker分配一个伪终端并绑定到容器的标准输入上-i 是让容器的标准输入保持打开状态-p 指定映射端口 还能这么写： 123docker run --name mssql -e &#x27;ACCEPT_EULA=Y&#x27; -e &#x27;SA_PASSWORD=xxxx&#x27; \\ -p 1433:1433 \\ -d mssql-2019-with-cimb \\应该是可以换行表述-e 定义环境变量（通常制作镜像的时候应该已经写好了，或者在容器内做好自动脚本，run时候再写毕竟是不方便的） 1.2 将此容器 commit 保存为新镜像：格式： 1docker commit container-id new-name container-id也可以是已有容器的名字，例如： 1docker commit node-test nodehexo nodehexo这里是新镜像名 1.3 启动docker引擎时自动运行docker容器：https://blog.csdn.net/londa/article/details/97611947 ps:上面链接文章还有:修改docker容器的挂载路径，修改docker默认的存储位置 1docker run --restart=always 有时候，我们创建容器时忘了添加参数 --restart=always ，当 Docker 重启时，容器未能自动启动， 现在要添加该参数怎么办呢，方法有二： 1、Docker 命令修改 1docker container update --restart=always 容器名字 我实际运行时，可以支持同时配置多个容器id，比如（其中container关键字可以忽略不写） 1docker update 87cd61ad7f7c f488b0479f24 2109903220ce 1fb346ea1a46 --restart=no 2、直接改配置文件 首先停止容器，不然无法修改配置文件 配置文件路径为：/var/lib/docker/containers/ 容器ID 在该目录下找到一个文件 hostconfig.json ，找到该文件中关键字 RestartPolicy 修改前配置：&quot;RestartPolicy&quot;:&#123;&quot;Name&quot;:&quot;no&quot;,&quot;MaximumRetryCount&quot;:0&#125; 修改后配置：&quot;RestartPolicy&quot;:&#123;&quot;Name&quot;:&quot;always&quot;,&quot;MaximumRetryCount&quot;:0&#125; 最后启动容器。 1.4 有关dockerfiledockerfile是用来构建镜像的脚本主要参考这几篇：https://www.runoob.com/docker/docker-dockerfile.htmlhttps://developer.aliyun.com/article/484262docker容器启动时自动启动脚本 编写dockerfile我的第一个dockerfile：简单做个测试，在之前做的镜像上加了条启动命令Dockerfile （文件没有后缀) 1234## Set the base image to CentOS 基于nodehexoFROM nodehexo:V4COPY ddnsstart.sh /ddnsstart.shENTRYPOINT [&quot;/bin/bash&quot;, &quot;/ddnsstart.sh&quot;] 很简单:FROM基于nodehexo:V4镜像构建COPY就是拷贝构建目录下的ddnsstart.sh到之后构建好的镜像根目录下ENTRYPOINT会在用新镜像开启容器时再执行，这里会在执行/bin/bash里执行/ddnsstart.sh 一个dockerfile只能有一条ENTRYPOINT，多个也只执行最后一个,CMD也是如此如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。 关于CMD还有些写法，比如还可以CMD service ssh start &amp;&amp; service XXX start &amp;&amp; tail -f /etc/passwd一起执行多道指令这在构建镜像的时候会被自动转换为类似：CMD [&quot;/bin/sh&quot;, &quot;service ssh start&quot;,&quot;service XXX start&quot;,&quot;tail -f /etc/passwd&quot;] tail -f /etc/passwd作用在于防止docker容器开启后立即关闭见下面段落 CMD格式： 123CMD &lt;shell 命令&gt; CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认是 bin/sh ddnsstart.sh文件 12345#!/bin/bashroot/ddnsAPP/ddns -c root/ddnsAPP/config.jsonecho &quot;更新mcwrite.winotmk.com解析&quot;service ssh starttail -f /etc/passwd 这里都是简单的shell命令了root/ddnsAPP/ddns -c root/ddnsAPP/config.json是执行ddns更新，解析新的ip到域名上，因为我这个镜像打算放到阿里云ECI里跑，每次新拉的IP当然都不一样（一直占着一个IP会产生费用，没必要） 同时我还执行了启动ssh服务，有的时候会用上ssh，因为我把网盘挂载到了容器内tail -f /etc/passwd这里起到的比较重要的占着进程的作用，详见下面： *关于 CMD 或 entrypoint 构建后 docker run -dit 为何容器依然秒退https://www.zhihu.com/question/344939968是因为使用了CMD或者entrypoint去service *** start命令作为容器启动命令，主进程执行完结束了，容器也就结束了 dockerfile 写清楚 entrypoint 和 cmd，启动脚本如果立刻会退出，那么在最后添加 tail -f 某个日志文件。或者 监听某个端口或者进程。方法1: 设置容器启动时就启动服务ENTRYPOINT [“flask”, “run”, “-h”, “0.0.0.0”, “-p”, “80”]方法2:CMD service apache2 start &amp;&amp; tail -F /var/log/apache2/error.log再极端点 sleep infinite 用dockerfile构建镜像docker build -t &lt;新镜像名字:标签&gt; .比如docker build -t nodehexo:V5 .请不要忘记最后一个.，这表示在当前目录下构建用这条指令前先CD到dockerfile文件所放置的目录比如我先CD ./dockerbuild，因为我的文件放在用户/dockerbuild目录下面然后就拥有了属于构建的镜像！ 1.4.1 ENTRYPOINT与CMD的区别Docker 的 ENTRYPOINT 和 CMD 参数探秘https://aws.amazon.com/cn/blogs/china/demystifying-entrypoint-cmd-docker/ 1.4.2 dockerfile构建镜像时如何选择FROM镜像以减小镜像体积busybox：https://blog.csdn.net/hknaruto/article/details/70229896alpine：https://hub.docker.com/_/alpinealpine包管理器APK：https://wangchujiang.com/linux-command/c/apk.htmlhttps://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper 1.5 将已有镜像打包带走/使用将打包来的镜像https://zhuanlan.zhihu.com/p/348849578 将镜像保存为本地文件可以使用Docker save命令 1docker save -o mssql-2019-with-cimb.tar mssql-2019-with-cimb 会得到一个mssql-2019-with-cimb.tar文件，就可以随身携带啦 从文件载入镜像 从文件载入镜像使用Docker load命令: 1docker load --input mssql-2019-with-cimb.tar 1.6 docker挂载本地目录有关volume:https://docs.docker.com/storage/volumes/https://docs.docker.com/get-started/05_persisting_data/https://blog.csdn.net/zz00008888/article/details/131924286 在Docker中，可以使用“-v”选项来挂载本地目录。该选项需要两个参数，分别是本地目录路径和容器内目录路径。例如，以下命令将本地目录“/home/user/app”挂载到容器内的“/app”目录中： 1docker run -v /home/user/app:/app my_image 这将使得容器可以访问本地目录中的文件，并且任何对该目录的更改也会反映在容器中。 Docker挂载本地目录到已有容器 除了在容器启动时挂载本地目录外，还可以在运行时将本地目录挂载到正在运行的容器中。要实现这一点，可以使用“docker cp”命令将本地目录复制到容器中，并使用“docker exec”命令在容器中执行命令。例如，以下命令将本地目录“/home/user/data”挂载到正在运行的容器中： 12docker cp /home/user/data my_container:/datadocker exec -it my_container bash 在容器中，可以访问挂载的目录“/data”，并且任何对该目录的更改也会反映在本地文件系统中。 1.7 其他一些操作12345678910111213141516171819202122232425# ****************************** 容器 ****************************** ## 查看正在运行的容器$ docker ps# 查看所有容器$ docker ps -a# 启动/停止某个容器$ docker start/stop id/name# 以交互方式启动一个容器$ docker start -i id/name# 进入某个容器(使用exit退出后容器也跟着停止运行)$ docker attach id/name# 启动一个伪终端以交互式的方式进入某个运行的容器（使用exit退出后容器不停止运行）$ docker exec -it id/name# 删除某个容器$ docker rm id/name# 复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash$ docker run --name test -ti ubuntu /bin/bash# ****************************** 镜像 ****************************** ## 查看本地镜像$ docker images# 删除某个镜像$ docker rmi id/name# 基于当前目录下的Dockerfile，创建一个名为name:flag的镜像$ docker build -t name:flag . 2. 已启动容器操作2.1 win10下docker给已存在的容器添加端口映射的方法博主再吐槽一下，这个调试阶段如此常用的修改容我端口，改起来却像游戏作弊，不觉得这个要做简单很难，怕只是没做https://mdnice.com/writing/25822ca29531424d9b68d7feb8273a82https://blog.csdn.net/Taysuesue/article/details/126706394https://www.cnblogs.com/kingsonfu/p/11578073.html 查看容器已映射的端口（dockerdeskUI内也可看见） 1docker port 容器ID/容器名 先停止容器 1docker stop &#123;容器的名称或者 id &#125; 查看容器完整的 hash_of_the_container 数值： 123456docker inspect &#123;容器的名称或者 id &#125; | grep Id# 比如：docker inspect cbe26510c276 | grep Id# 会得到如下结果：# &quot;Id&quot;: &quot;cbe26510c276fa9a4487a8c2af8cbb49410f2a5305149d2b26eb8ce37c777d00&quot; 如果主机是linux（mac应该也行没测）打开 hostconfig.json 配置文件: 1vim /var/lib/docker/containers/&#123;hash_of_the_container&#125;/hostconfig.json 记得还要改 config.v2.json，改法同下面的win10如果是win101.先找到容器的配置文件，首先我的电脑地址栏输\\wsl$\\进入到网络文件夹上,在一步一步找到容器目录 1\\\\wsl$\\docker-desktop-data\\data\\docker\\containers 2.点击进入相应容器ID文件夹，打开后修改其中的 config.v2.json 和 hostconfig.json hostconfig.json 1&quot;PortBindings&quot;:&#123;&quot;22/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;50022&quot;&#125;],&quot;3306/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;53306&quot;&#125;],&quot;6379/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;56379&quot;&#125;]&#125; 这里的HostPort字面意思就是宿主机的端口，所以即：容器内22&gt;外部5022访问容器内3306&gt;外部53306访问容器内6379&gt;外部56379访问 config.v2.json 有两处需要添加，只修改一处不生效 1&quot;ExposedPorts&quot;:&#123;&quot;22/tcp&quot;:&#123;&#125;,&quot;3306/tcp&quot;:&#123;&#125;,&quot;6379/tcp&quot;:&#123;&#125;&#125; 1&quot;Ports&quot;:&#123;&quot;22/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;0.0.0.0&quot;,&quot;HostPort&quot;:&quot;50022&quot;&#125;],&quot;3306/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;0.0.0.0&quot;,&quot;HostPort&quot;:&quot;53306&quot;&#125;],&quot;6379/tcp&quot;:[&#123;&quot;HostIp&quot;:&quot;0.0.0.0&quot;,&quot;HostPort&quot;:&quot;56379&quot;&#125;]&#125; 不过我实际只改了这里的&quot;ExposedPorts&quot;貌似就行了 然后重启docker，注意不只是重启容器，我一开始只重启容器发现白改了 12# 重启 dockerservice docker restart 或者在系统右下角，点击Restart重启整个 Docker 服务，然后再重启 Container 即可正常使用 2.2 docker容器内服务开机自启动实现方案（以ssh服务为例）注意，2.2这段内容随着对docker和linux了解的深入觉得有不妥，但是作为学习的过程还是保留 https://blog.csdn.net/qq_38603541/article/details/124028994 因为我后续打算用类似vscode里的remote-ssh来管理容器内，也想用winscp等好用的工具可以接进来，还是有必要开个ssh解决方案1、正常我们在linux操作系统内设置服务自启动的方法一般都是使用systemctl。 systemctl enable ssh2、但是，一般在docker容器内我们一般不这么干，因为容器内没有systemctl权限…… 3、我们依然还是使用脚本的形式将ssh设为自启，只不过这个的这个脚本和我们使用Dockerfile的脚本不一样。 4、在 /root 目录下新建一个 start_ssh.sh文件，并给予该文件可执行权限。 12345touch /root/start_ssh.sh vim /root/start_ssh.sh chmod +x /root/start_ssh.sh 5、start_ssh.sh 脚本的内容，如下： 123456#!/bin/bash LOGTIME=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)echo &quot;[$LOGTIME] startup run...&quot; &gt;&gt;/root/start_ssh.logservice ssh start &gt;&gt;/root/start_ssh.log#service mysql start &gt;&gt;/root/star_mysql.log //其他服务也可这么实现 6、将start_ssh.sh脚本添加到启动文件中 1vim /root/.bashrc 7、在 .bashrc 文件末尾加入如下内容： 1234# startup runif [ -f /root/start_ssh.sh ]; then . /root/start_ssh.shfi 8、保存后，等下次重启容器的时候，添加的服务也就跟着重启了。 docker容器在启动的时候，会自动执行的是~/.bashrc文件，所以，环境变量需要配置在该文件内，这样镜像启动时，可自动执行该文件，使环境变量生效。 正确的理解是：/root/.bashrc会在容器启动的时候自动执行这句十分欠妥，准确的来讲是root用户登录bash的时候会执行，每次开新的bash shell也会执行一遍如果dockerfile内定义了ENTRYPOINT或者CMD执行类似： 1ENTRYPOINT [ &quot;/bin/bash&quot;,&quot;-c&quot;,&quot;service apache2 start&quot; ] 那么对于容器来说PID 1号进程就是bash（apache是bash的子进程），也确实会跑一遍.bashrc内的内容，但是这不代表所有容器启动时一定会启动bash shell，也可能直接是个java进程，也可能是dumb-int，更多时候可能是sh shell，这应该都不会触发.bashrc所以如果想要在容器启动时自动启动一个服务，推荐写在dockerfile里，比如 12COPY start.sh /ENTRYPOINT [ &quot;sh&quot;,&quot;/start.sh&quot; ] 然后再在start.sh里写上你需要启动的服务 123#!/bin/shservice ssh restartservice apache2 restart 以及如果确实有很多个服务需要启，考虑使用类似docker compose启多个镜像，每个镜像跑单个服务 2.2.1 拓展：~/.bashrc /etc/bashrc /etc/profile三个文件的区别https://segmentfault.com/q/1010000003793341 3 打包制作自己的docker镜像(dockerfile)dockerfile是告诉docker engine如何构建镜像的脚本 3.1 node.js+git+hexo镜像其实这部分镜像做了两遍，第一遍直接拉的官方node镜像，然后发现ssh不好装，走了很多弯路，随着对docker了解的加深，最后我自己做了dockerfile重构了这部分镜像 3.1.1 DockerfiledockerfileV02（可以没有后缀） 123456789101112131415161718192021222324252627282930#这个包将包含：node-v29.5.0 git ssh hexo#hexo环境目录/hexo/WinblogFROM debian:stable-slimLABEL maintainer=&quot;winotmk&quot; web=&quot;md.winotmk.com&quot; Ver=&quot;02&quot;#ADD有自动解压功能ADD node-v20.5.0-linux-x64.tar.xz / #移动node二进制文件到目录RUN mkdir -p /usr/local/nodejs &amp;&amp;\\ mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;&amp;\\ #mk hexo目录 mkdir -p /hexo/Winblog &amp;&amp;\\ apt-get update &amp;&amp;\\ #安装SSH 安装GIT apt-get install -y --no-install-recommends openssh-server git-core &amp;&amp;\\ apt-get autoremove -y &amp;&amp;\\ apt-get clean#node和npm环境变量ENV PATH=&quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&quot;#安装hexoWORKDIR /hexo/WinblogRUN npm install -g hexo-cli#hexo环境变量ENV PATH=&quot;$PATH:/hexo/Winblog/node_modules/.bin&quot;#更新ssh设置COPY sshd_config /etc/ssh/#环境变量设置COPY .profile /root/#设置启动脚本COPY hexo_debian_service_start.sh /service_start.shCMD [&quot;/bin/bash&quot;,&quot;/service_start.sh&quot;] 基本上都是些安装命令以及配置环境变量安装了hexo,git,ssh,node这是优化过了的第二版，主要是第二版使用了ADD，它基本和COPY一样，都可以把某个构建目录下的文件打入正在生成的镜像里，但当用ADD在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。说白了ADD会帮我自动解压在这里我还设置了ssh（但是没有配置root密码） 而我的第一版开头：dockerfileV01 1234567891011121314151617FROM debian:stable-slimCOPY node-v20.5.0-linux-x64.tar.xz /node-v20.5.0-linux-x64.tar.xzRUN apt-get update &amp;&amp;\\ apt-get install -y xz-utils --no-install-recommends &amp;&amp;\\ tar -xvf node-v20.5.0-linux-x64.tar.xz &amp;&amp;\\ mkdir -p /usr/local/nodejs &amp;&amp;\\ mv node-v20.5.0-linux-x64 /usr/local/nodejs &amp;&amp;\\ #删除xz包 apt-get purge -y xz-utils &amp;&amp; \\ apt-get autoremove -y &amp;&amp; \\ apt-get clean &amp;&amp; \\ #删除node-v20.5.0-linux-x64.tar.xz包 rm node-v20.5.0-linux-x64.tar.xz#node和npm环境变量ENV PATH=&quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&quot; 当时不知道ADD的功能，使用 COPY拷贝整个.tar.xz包结果debian还没有.xz包解压功能，需要安装xz-utils详见，凭空多出好几行 为什么要用二进制包安装呢node.js呢？因为实测如果用apt-get install nodejs安装，或者curl -fsSL https://deb.nodesource.com/setup_19.x | bash - &amp;&amp;\\ apt-get install -y nodejs命令出处，安装出来镜像体积就是会楞大出好几百MB 3.1.2 node.js+git+hexo镜像COPY的文件.profile 123456789101112# ~/.profile: executed by Bourne-compatible login shells.if [ &quot;$BASH&quot; ]; then if [ -f ~/.bashrc ]; then . ~/.bashrc fifimesg n 2&gt; /dev/null || trueexport PATH=&quot;/usr/local/nodejs/node-v20.5.0-linux-x64/bin:$PATH&quot;export PATH=&quot;$PATH:/hexo/Winblog/node_modules/.bin&quot; 为了防止镜像上云后莫名其妙的原因导致环境变量出问题，脚本里再跑一遍，这俩export PATH其实dockerfile里设置过 sshd_config是什么ssh的设置参考：https://blog.csdn.net/weixin_34910922/article/details/125193597主要改了两条 123#vim /etc/ssh/sshd_configPermitRootLogin yes #root登陆权限PasswordAuthentication yes #密码权限 等于我们预先改好了配置文件，在构建的时候再把配置放入容器里面 hexo_debian_service_start.sh 123456#!/bin/bash. ~/.profileLOGTIME=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)echo &quot;[$LOGTIME] startup run...&quot; &gt;&gt;/start_ssh.logservice ssh start &gt;&gt;/start_ssh.logtail -f /start_ssh.log 启动脚本，主要启动了ssh服务，并且用tail -f让这个容器一直运行以方便我们来连接 3.1.3 开始构建镜像先CD到Dockerfile所在的目录 1docker build -t hexo_debian:V02 -f dockerfileV02 . 格式是 1docker build -t 镜像名:tag -f Dockerfile文件名 . 注意.不要落下！ 这样我们的镜像就做好了！ 本节参考资料：二进制手动安装node参考：https://github.com/nodejs/help/wiki/Installationhttps://blog.51cto.com/u_13460811/4901015 一些关于dockerfile指令的说明：较详细： https://yeasy.gitbook.io/docker_practice/image/dockerfile/copyhttps://blog.csdn.net/qq_35528657/article/details/127244194https://www.runoob.com/docker/docker-dockerfile.html 在dockerfile里用apt-get包管理的建议：https://ubuntu.com/blog/we-reduced-our-docker-images-by-60-with-no-install-recommendshttps://www.metricfire.com/blog/how-to-build-optimal-docker-images/ hexo所需环境安装说明：https://hexo.io/zh-cn/docs/index.html 3.1.4 测试镜像功能来启个容器试试！ 1docker run -it -d -p 22:22 --name hexo_debian hexo_debian:V02 这里开放了22端口来方便验证ssh服务和登录ssh没有问题启动成功！容器内执行来验证服务状态都正常： 123sshnode -vgit -v 输出：可以看见一切正常！ 3.1.5 设置和再打包镜像设置毕竟自用镜像，我习惯直接把比如ssh密钥之类全都配置好，再commit为一个新镜像，以后就再也不用输密码了，这样确实不安全，但是自己的hexo博客而已，何必为难自己呢接下来设置root密码和重启ssh服务 123passwd root#然后敲自己设置的密码service ssh restart 尝试使用PuTTY进行SSH &#114;&#x6f;&#x6f;&#116;&#x40;&#49;&#x32;&#x37;&#x2e;&#48;&#x2e;&#x30;&#x2e;&#49;登录：成功!!!接下来配置git和ssh，要生成新的ssh公钥详见：https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent 1ssh-keygen -t ed25519 -C &quot;github邮箱@qq.com&quot; 得到密钥默认在/root/.ssh/id_ed25519.pub在Github的头像点Setting然后点右上角击New SSH key，把id_ed25519.pub内容粘贴进即可！测试SSH连接： 1ssh -T git@github.com 这样就连上了！需要进行一个小设置： 1git config --global user.email &quot;you@example.com&quot; 这样以后使用hexo d的时候就能无脑部署了 再打包为了存下我们配置好的连接，制作成最终镜像方便eci云上调用，把现有容器再commit一次 1docker commit hexo_debian hexo_debian:V02-configured 成了！得到了hexo_debian:V02-configured作为我最后准备上传至ECI云的镜像 3.1.6 附一些命令参考如何用ssh连接 docker 容器https://blog.csdn.net/weixin_34910922/article/details/125193597 1.修改root密码 12$ passwd root输入密码：123456(自己决定) 2.安装Openssh 123sudo apt-get update # 更新源sudo apt-get upgrade # 更新系统软件apt-get install -y openssh-server 3.修改ssh配置,允许root登录https://blog.csdn.net/weixin_43343144/article/details/102494830【非常重要】在/etc/ssh/ssh_config中没有PermitRootLogin yes选项的话，就要在sshd_config文件中寻找！ 123vim /etc/ssh/sshd_configPermitRootLogin yes #root登陆权限PasswordAuthentication yes #密码权限 4.启动ssh服务/重启服务 12service ssh startservice ssh restart 安装hexo1npm install hexo-cli -g SSH远程登录这个镜像之前在本机docker内已经配好了ssh服务，讲道理应该启动则开启ssh但是不知为啥没有自动启动，以后再研究吧打开Workbench远程连接，启动ssh由于我启用ECI时开通了弹性公网IP，所以我可以通过这个IP:22用ssh来登录使用PuTTY工具登录成功！！多么令人振奋的一刻 3.2 vsftpd镜像这个镜像比较简单，只跑ftp服务，主要在写作的时候方便上传图片 3.2.1 Dockerfilevsftpd_dockerfileV01 123456789101112#这个包将包含：vsftp（root登录）FROM debian:stable-slimLABEL maintainer=&quot;winotmk&quot; web=&quot;md.winotmk.com&quot; Ver=&quot;01&quot;RUN apt-get update &amp;&amp;\\ apt-get install -y vsftpd --no-install-recommends &amp;&amp;\\ apt-get autoremove -y &amp;&amp;\\ apt-get clean &amp;&amp;\\ echo &quot;root:yourpasswd&quot; | chpasswdCOPY ftpusers /etc/COPY vsftpd.conf /etc/COPY service_start.sh /service_start.shCMD [&quot;/bin/bash&quot;,&quot;/service_start.sh&quot;] 比较简单的dockerfile，就装了个vsftpd服务，然后拷贝了一些设置文件如果要在dockerfile里配置用户密码可以这么写： 1echo &quot;root:yourpasswd&quot; | chpasswd 3.2.2 vsftpd镜像COPY的文件service_start.sh 12345#!/bin/bashLOGTIME=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)echo &quot;[$LOGTIME] startup run...&quot; &gt;&gt;/start_vsftpd.logservice vsftpd start &gt;&gt;/start_vsftpd.logtail -f /start_vsftpd.log 简单的服务启动脚本，使用tail -f来维持住进程 ftpusersroot前加个#以启用root登录 1234567891011121314# /etc/ftpusers: list of users disallowed FTP access. See ftpusers(5).#rootdaemonbinsyssyncgamesmanlpmailnewsuucpnobody vsftpd.confftp设置文件，这个文件内容很多只些下修改的部分 12345678910listen=NOlisten_ipv6=YESanonymous_enable=NOlocal_enable=YESwrite_enable=YESdirmessage_enable=YESuse_localtime=YESconnect_from_port_20=YESpam_service_name=vsftpdutf8_filesystem=YES *关于修改vsftpd的端口https://askubuntu.com/questions/37058/how-to-change-vsftpd-default-portvsftpd.conf里的设置不是完全设置，可以自己增加字段 1234listen_port=234ftp_data_port=235pasv_min_port=30000pasv_max_port=31000 来设置端口注意FTP默认20传输数据，21用来listen，所以改得话干脆两个都改吧 *这里遇到过一个小坑坑构建器报错，一直卡在Starting FTP server: vsftpdvsftpd failed - probably invalid config. ... (warning).自己在容器内运行service vsftpd start的时候同样如此，一般这样是因为vsftpd.conf文件设置错了，可神奇的是我只要打开dockerDesktop的Files文件管理把vsftpd.conf打开再保存一下就可以成功运行service vsftpd start我发现这个文件的格式是UTF-8 CRLF修改为LF即可顺利启动vsftpd服务 参考：https://www.cnblogs.com/Dreamcho/p/10805690.html 如果要在dockerfile里加用户：https://blog.csdn.net/u010275850/article/details/120587850 3.3 ddns镜像这个镜像更简单？只在启动的时候跑一个ddns但是我却在这里卡了很久原因之一是因为一开始选用的ddns软件本地跑得好好的，在阿里云上总是报错，log显示已经修改了a记录但是自己去一看啥也没有，很是困惑，所以换了个软件实现最开始使用的是这个软件，配置方便https://github.com/NewFuture/DDNS参考：https://blog.csdn.net/biao0309/article/details/117202951无奈阿里云上即便是用官方提供的镜像newfuture/ddns也会报错（恼 所以我改用ddns-go:https://github.com/jeessy2/ddns-go先贴上官方镜像的层：jeessy/ddns-go我们的新镜像将基于官方镜像来做 3.3.1 dockerfileddns-go_dockerfileV01 1234567FROM jeessy/ddns-goLABEL maintainer=&quot;winotmk&quot; web=&quot;md.winotmk.com&quot; Ver=&quot;01&quot;COPY ddns_start.sh /COPY ddns_go_config.yaml /ENV DDNS_URL=ENTRYPOINT [ &quot;sh&quot;,&quot;/ddns_start.sh&quot; ]CMD [ &quot;&quot; ] 这里做了一个变量$DDNS_URL来定义我想要dns的域名(当然这个域名我得拥有)ENTRYPOINT和CMD的设置会覆盖掉的之前镜像内的设置我不确定CMD [ “” ]是否有必要，但总之我想使官方镜像里的CMD失效，从结果上来看管用 3.3.2 ddns镜像COPY的文件ddns_go_config.yaml 12345678910111213141516171819202122232425262728293031dnsconf: - ipv4: enable: true gettype: url url: https://myip4.ipip.net,https://ddns.oray.com/checkip,https://ip.3322.net,https://4.ipw.cn netinterface: &quot;&quot; cmd: &quot;&quot; domains: - null.winotmk.com ipv6: enable: false gettype: netInterface url: https://speed.neu6.edu.cn/getIP.php,https://v6.ident.me,https://6.ipw.cn netinterface: &quot;&quot; cmd: &quot;&quot; ipv6reg: &quot;&quot; domains: - &quot;&quot; dns: name: alidns id: 阿里云的AccessKey ID secret: 阿里云的AccessKey secret ttl: &quot;&quot;user: username: &quot;&quot; password: &quot;&quot;webhook: webhookurl: &quot;&quot; webhookrequestbody: &quot;&quot; webhookheaders: &quot;&quot;notallowwanaccess: true 这个是ddns-go的配置文件，第一次启动会在本地:9876打开个web界面，保存设置后会在root中生成这个文件，这里我直接引入这个文件是希望后面能用sed命令对文件的domains字段进行修改 ddns_start.sh 12345678910111213141516#!/bin/shLOGTIME=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)echo &quot;[$LOGTIME] startup run...&quot; &gt;&gt;/start_ddns.logcd /if [ &quot;$DDNS_URL&quot; = &quot;&quot; ] then echo &quot;DDNS_URL is not set!&quot; &gt;&gt;/start_ddns.log tail -f /start_ddns.log else sed -i &quot;s/null.winotmk.com/$DDNS_URL/g&quot; ddns_go_config.yaml #chmod 777 ddns_go_config.yaml sleep 3 /app/ddns-go -l :9876 -f 300 -c /ddns_go_config.yaml echo &quot;已执行更新[$DDNS_URL]解析&quot; &gt;&gt;/start_ddns.log tail -f /start_ddns.logfi 在这个脚本里会判断$DDNS_URL是否为空，空的话直接输出需要$DDNS_URL设置如果不为空的话会通过sed替换字符，这里设置文件内默认写得是null.winotmk.com用这种方式去直接修改设置文件，是因为我没找到这个软件是否能直接用环境变量来定义解析到的域名 关于用sed替换congif.json设置内的字段：如何使用sed:https://linux.cn/article-11367-1.html如何在sed命令内使用变量https://www.cnblogs.com/muahao/p/6874412.html判断变量是否为空的方法：https://cloud.tencent.com/developer/article/1721905 4 docker镜像打包并上传到阿里云镜像库ARK将自己的镜像上传至阿里云：阿里云提供容器镜像服务，我自己玩开通个人实例即可https://cr.console.aliyun.com/cn-shanghai/instances 建立一个自己的仓库，然后就能看到示例说明，我们就能把自己的镜像上传了 4.1 将镜像推送到Registry123$ docker login --username=*****@qq.com registry.cn-shanghai.aliyuncs.com$ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/******:[镜像版本号]$ docker push registry.cn-shanghai.aliyuncs.com/******:[镜像版本号] tag是类似复制一份且重命名镜像，push是上传（不知道为什么要重命名 针对上面的3个镜像，分别是：node.js+git+hexo,vsftpd,ddns-go我分别tag成了： 123registry-vpc.cn-shanghai.aliyuncs.com/******:debian_V02_configured #应该写成:hexo_debian_V02_configured的，漏了。。算了registry-vpc.cn-shanghai.aliyuncs.com/******:vsftpd_debian_V01registry-vpc.cn-shanghai.aliyuncs.com/******:ddns_go_V01 再分别push即可 4.2 在阿里云上使用容器实例（ECI）运行镜像阿里云ECI提供这个服务，你可以直接用现有的镜像也可以自己上传（就是上一步镜像服务里上传的镜像）按秒收费！不过作为hexo这种启用&gt;生成&gt;部署&gt;关闭的服务来说，花不了几毛钱 然后就能看到我们上传的镜像 5 eci容器创建模板和eci命令行工具使用参考文章这两篇足够:https://github.com/aliyuneci/eci-client-doc/blob/main/eci_run.mdhttps://help.aliyun.com/document_detail/186961.html 5.1 eci简介https://www.aliyun.com/product/eciECI是 Serverless 和容器化的弹性计算服务。您无需管理底层 ECS 服务器，只需要提供打包好的镜像，即可运行容器，与阿里云容器服务无缝对接并仅为容器实际运行消耗的资源付费。 博主：比ECS云服务器灵活得多，本地用docker制作好镜像以后，上传，随启随用，用完就释放，成本可以很低,但如果连开一个月，并不会比ECS划算，详见本站ECI价格计算附表 5.2 用模板创建eci询问过阿里云客服，说在web控制面版里的这个功能已经下线了不过没关系，我们还有命令行工具！安装： 1sudo bash -c &quot;$(curl -s https://eci-docs.oss-cn-beijing.aliyuncs.com/eci-client/1.0/install.sh)&quot; 然后配置你的阿里云信息 123456eci config set-context \\--access-key-id **** \\--access-secret **** \\--region-id cn-shanghai \\--security-group-id sg-**** \\--v-switch-id vsw-**** 要指定自己的access-key-id和access-secret，地区以及安全组和虚拟交换机建议这些东西在web上的控制台里准备好，会直观很多 然后就可以直接创建一个容器了 1eci run -n myeci centos:7 sleep 3600 指令很像docker run喝！很好，很有精神 我们还可以编写yaml模板文件然后执行 1eci run -f eci.yaml -w 20 需要注意的事，如果使用了-f xxxx.yaml模板文件，除了-f和-w选项以外，其他选项都将被忽略，因为这些选项都是针对实例中某个容器的，如果模板中定义了多个容器，ECI将不知道这些选项应该作用于哪个容器那么我自己的启动模板是这样的：hexo_debian_eci.yaml 123456789101112131415161718192021222324252627282930313233343536ContainerGroupName: eci-hexoCpu: &quot;0.5&quot;Memory: &quot;1&quot;Container:- Name: hexo Image: registry-vpc.cn-shanghai.aliyuncs.com/****:debian_V02_configured Command: [&quot;/bin/bash&quot;,&quot;/service_start.sh&quot;] ImagePullPolicy: IfNotPresent Cpu: &quot;0.5&quot; Memory: &quot;1&quot; VolumeMount: - Name: hexo MountPath: /hexo ReadOnly: false- Name: vsftpd Image: registry-vpc.cn-shanghai.aliyuncs.com/****:vsftpd_debian_V01 Command: [&quot;/bin/bash&quot;,&quot;/service_start.sh&quot;] ImagePullPolicy: IfNotPresent VolumeMount: - Name: hexo MountPath: /hexo ReadOnly: false- Name: ddns Image: registry-vpc.cn-shanghai.aliyuncs.com/****:ddns_go_V01 ImagePullPolicy: IfNotPresent EnvironmentVar: - FieldRefFieldPath: &quot;&quot; Key: DDNS_URL Value: mdwrite.winotmk.comVolume:- Name: hexo Type: NFSVolume NFSVolume: Server: ****.cn-shanghai.nas.aliyuncs.com Path: / ReadOnly: false 是不是挺像docker compose~ cpu只给了0.5,Memory 1G，足够了，之前这套可是在树莓派3B上跑得溜溜得呢对于阿里云ECI，CPU和Memory直接和成本挂钩，能少就少吧 这里启了上面做好的3个镜像，分别实现hexo，ftp，还有ddnsCommand:写法目测类似dockerfile里的CMD，我习惯做好启动sh脚本就是为了方便这里再调用最后一段声明了我的一个阿里云NAS卷，卷里的内容就是我的hexo目录然后把它挂到hexo和ftp镜像上就好了 值得一提的是ddns镜像还写了个环境变量DDNS_URL值为mdwrite.winotmk.com，这会修改ddns-go的解析配置 然后执行 1eci run -f hexo_debian_eci.yaml -w 20 不出意外的话会返回一个eci的id编号，打开web会发现已经创建成功了！ 6 hexo本地编辑环境设置————如何用VSCode舒服的写MD文档6.1 VSCodeSSH FS插件配置简单配置一下服务器地址和用户密码就可以把远程目录映射到工作区里，很方便这里可以看到/root/hexo/Winblog目录下是我挂载的阿里云NAS网盘了 6.2 Markdown Paste插件配置一个很方便的在VScode里直接粘图的插件 配置：会用时间来命名图片然后会将图片放入MD文件目录下的images下 然后文件》首选项》键盘快捷方式我将快捷键设置为ctrl+alt+a配置完成！ 使用：截图我习惯用Sinpaste，按F1就能截图然后点右下角复制按钮在VScode的markdown文档里ctrl+alt+a就能粘图了！图片文件会自动保存! 6.2 VSCode的SFTP插件配置先把images文件夹单独放到工作区里然后在Ctrl+Shift+P打开命令面板，运行SFTP: config命令sftp.json目录下会出现一个名为的基本配置文件.vscode然后编辑sftp.json 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;Hexo_images&quot;, &quot;host&quot;: &quot;mdwrite.winotmk.com&quot;, &quot;protocol&quot;: &quot;ftp&quot;, &quot;port&quot;: 21, &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;****&quot;, &quot;remotePath&quot;: &quot;/hexo/Winblog/source/images&quot;, &quot;useTempFile&quot;: false, &quot;openSsh&quot;: false, &quot;uploadOnSave&quot;: false, &quot;watcher&quot;: &#123; &quot;files&quot;: &quot;**/*&quot;, &quot;autoUpload&quot;: true, &quot;autoDelete&quot;: true &#125;, &quot;syncOption&quot;: &#123; &quot;delete&quot;: true &#125;&#125; &quot;watcher&quot;是用来设置自动更新的这样我们在md里粘了图，就会自动上传到到ftp目录上 参考：https://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp#remote-explorer开启watcher模式，实现增加文件时自动上传目录同步https://github.com/Natizyskunk/vscode-sftp/blob/master/FAQ.md#automatically-sync-both-ways-without-user-interaction","categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"}],"tags":[{"name":"阿里云","slug":"阿里云","permalink":"https://winotmk.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"eci","slug":"eci","permalink":"https://winotmk.github.io/tags/eci/"},{"name":"hexo","slug":"hexo","permalink":"https://winotmk.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://winotmk.github.io/tags/next/"},{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"}]},{"title":"next主题增加近期文章侧边栏","slug":"next主题增加近期文章侧边栏","date":"2023-07-26T16:00:00.000Z","updated":"2023-07-27T04:19:35.000Z","comments":true,"path":"next主题增加近期文章侧边栏/","link":"","permalink":"https://winotmk.github.io/next%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E8%BF%91%E6%9C%9F%E6%96%87%E7%AB%A0%E4%BE%A7%E8%BE%B9%E6%A0%8F/","excerpt":"边栏显示文章列表效果我还奇怪next没用提供这样的功能，文章一多一篇篇翻实在是累，还好找到了有人实现最近文章的功能，那么做文章列表也就同理了我修改过的代码首先是： sidebar.njk/hexo-theme-next/layout/_macro/sidebar.njk在最后一个&#123;% endif %&#125;后面加入 12345678910111213141516171819&#123;% if theme.recent_posts.enable %&#125; &lt;div class=&quot;links-of-blogroll&quot; style=&quot;margin-top:20px; border-style:dotted none none none; padding-top:5px; text-align:left;padding-left: 20px; padding-right: 10px; padding-bottom: 5px;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot; style=&quot;padding-bottom: 5px; padding-top: 5px; padding-left: 0px; padding-right: 20px; font-size: 1.6em; argin-right: 5px;&quot;&gt; &lt;!-- 选择合适的icon --&gt; &#123;%- if theme.recent_posts.icon %&#125;&lt;i class=&quot;&#123;&#123; theme.recent_posts.icon &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#123;%- endif %&#125; &lt;b style=&quot;font-size: 0.65em; padding-left: 8px; position: relative; top: -2px;&quot;&gt;&#123;&#123; theme.recent_posts.description &#125;&#125;&lt;/b&gt; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &lt;!-- 文章排序规格,-updated 按照文章更新时间倒排 --&gt; &#123;% set posts = site.posts.sort(&#x27;-updated&#x27;).toArray() %&#125; &lt;!-- 显示20数目的文章 --&gt; &#123;% for post in posts.slice(&#x27;0&#x27;,&#x27;20&#x27;) %&#125; &lt;li class=&quot;postsSidebarNumb&quot; style=&quot;text-indent: -1em;&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125;","text":"边栏显示文章列表效果我还奇怪next没用提供这样的功能，文章一多一篇篇翻实在是累，还好找到了有人实现最近文章的功能，那么做文章列表也就同理了我修改过的代码首先是： sidebar.njk/hexo-theme-next/layout/_macro/sidebar.njk在最后一个&#123;% endif %&#125;后面加入 12345678910111213141516171819&#123;% if theme.recent_posts.enable %&#125; &lt;div class=&quot;links-of-blogroll&quot; style=&quot;margin-top:20px; border-style:dotted none none none; padding-top:5px; text-align:left;padding-left: 20px; padding-right: 10px; padding-bottom: 5px;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot; style=&quot;padding-bottom: 5px; padding-top: 5px; padding-left: 0px; padding-right: 20px; font-size: 1.6em; argin-right: 5px;&quot;&gt; &lt;!-- 选择合适的icon --&gt; &#123;%- if theme.recent_posts.icon %&#125;&lt;i class=&quot;&#123;&#123; theme.recent_posts.icon &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#123;%- endif %&#125; &lt;b style=&quot;font-size: 0.65em; padding-left: 8px; position: relative; top: -2px;&quot;&gt;&#123;&#123; theme.recent_posts.description &#125;&#125;&lt;/b&gt; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &lt;!-- 文章排序规格,-updated 按照文章更新时间倒排 --&gt; &#123;% set posts = site.posts.sort(&#x27;-updated&#x27;).toArray() %&#125; &lt;!-- 显示20数目的文章 --&gt; &#123;% for post in posts.slice(&#x27;0&#x27;,&#x27;20&#x27;) %&#125; &lt;li class=&quot;postsSidebarNumb&quot; style=&quot;text-indent: -1em;&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; 出于美观我把一些css代码内嵌进去了其实不推荐这样做（寄 _config.yml/hexo-theme-next/_config.yml 12345# 近期文章配置 recent_posts: enable: true icon: fab fa-markdown description: 文章列表 main.styl/hexo-theme-next/source/css/main.styl是因为我想给文章列表加上计数，直接在css里用伪类做（要不是伪类不能html内嵌写进去我也不写这里 123456789//侧边栏计数伪类body &#123;counter-reset: postsSidebarNumbsection; &#125;.postsSidebarNumb::before &#123; counter-increment: postsSidebarNumbsection; content: counter(postsSidebarNumbsection) &quot;: &quot;;&#125; 一些搜集资料ps在查找的过程中发现提到这些的多半是next主题，而且别人的next主题都挺有意思的啊想搬！（爬 资料01：Hexo博客：(7)给NexT主题添加最新文章模块首先是这篇https://pickear.github.io/2020/04/12提到了：next/layout/_macro/sidebar.swig ,这个负责渲染侧边栏。在sidebar.swig的if theme.links的end if后面添加以下代码: 1234567891011121314151617&#123;% if theme.recent_posts %&#125;&lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;!-- modify icon to fire by szw --&gt; &lt;i class=&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts_title &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% set posts = site.posts.sort(&#x27;-date&#x27;) %&#125; &#123;% for post in posts.slice(&#x27;0&#x27;, &#x27;5&#x27;) %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&lt;/div&gt;&#123;% endif %&#125; 然后在NexT主题目录下的_config.yaml配置文件，添加下面配置: 123recent_posts_title: 最新文章recent_posts_layout: blockrecent_posts: true 然而实际效果是只会显示“最新文章”几个字查了得知 NexT 的架構檔案格式從 swig 改成 njk，照著舊的文章貼上不會成功 资料02：[Day33] Hexo x NexT - 顯示最新文章、導入Google Analytics 的坑接着是这篇，感谢提到了next主题架构更变的问题https://ithelp.ithome.com.tw/articles/10283488?sc=iThomeR 左側選單顯示最新文章 NexT 已經有 hexo-related-popular-posts 套件來顯示最新文章列表的功能，但是這個套件似乎沒辦法正常運作，網路上有不少教學文章，但是 NexT 的架構檔案格式從 swig 改成 njk，照著舊的文章貼上不會成功，設定步驟如下： 在 sidebar.njk 檔案裡面加入下段程式碼（跟 swig 版本就只差了一個 .toArray() ） 1234567891011121314151617&#123;%- if theme.recent_posts %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;!-- 設定你要的fa fa icon--&gt; &lt;i class=&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot; style=&quot;margin: 1rem 0.25rem 0.5rem 0&quot;&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts_title &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;%- set posts = site.posts.sort(&#x27;-date&#x27;) %&#125; &#123;%- for post in posts.slice(&#x27;0&#x27;, &#x27;5&#x27;).toArray() %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;%- endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;%- endif %&#125; 资料03: Hexo-NexT 后续优化https://blog.yileaf.com/posts/15baca53/我最后使用的基本上参考了这篇的代码 侧边栏添加近期文章1.打开blog\\source\\_data\\sidebar.njk文件，加入以下代码： 12345678910111213141516171819&#123;% if theme.recent_posts.enable %&#125; &lt;div class=&quot;links-of-blogroll&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;!-- 选择合适的icon --&gt; &#123;%- if theme.recent_posts.icon %&#125;&lt;i class=&quot;&#123;&#123; theme.recent_posts.icon &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#123;%- endif %&#125; &#123;&#123; theme.recent_posts.description &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &lt;!-- 文章排序规格,-updated 按照文章更新时间倒排 --&gt; &#123;% set posts = site.posts.sort(&#x27;-updated&#x27;).toArray() %&#125; &lt;!-- 显示四条近期文章 --&gt; &#123;% for post in posts.slice(&#x27;0&#x27;, &#x27;4&#x27;) %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; 2.主题config.yml 12345# 近期文章配置 recent_posts: enable: true icon: fas fa-history description: 近期文章","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://winotmk.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://winotmk.github.io/tags/next/"}]},{"title":"批处理实现批量改名以及SVN批量改名","slug":"bat","date":"2021-12-13T16:00:00.000Z","updated":"2021-12-16T07:32:31.000Z","comments":true,"path":"bat/","link":"","permalink":"https://winotmk.github.io/bat/","excerpt":"需求 注意Mesh和Texture前加了编号 工作需要整理目录文件，要将多组资产目录（Assets01,Assets02,Assets03…内的Resource目录下的Texture和Mesh目录加编号) 感觉这是一个可以用批处理脚本做到的事情，所以稍微研究了一下 改名实现如果单只是改名其实很简单，只需要几行即可实现： 1234@echo offfor /f &quot;delims=&quot; %%a in (&#x27;dir /ad/s/b &quot;Mesh&quot;&#x27;) do ren &quot;%%~a&quot; 01-Meshfor /f &quot;delims=&quot; %%b in (&#x27;dir /ad/s/b &quot;Texture&quot;&#x27;) do ren &quot;%%~b&quot; 00-Texturepause","text":"需求 注意Mesh和Texture前加了编号 工作需要整理目录文件，要将多组资产目录（Assets01,Assets02,Assets03…内的Resource目录下的Texture和Mesh目录加编号) 感觉这是一个可以用批处理脚本做到的事情，所以稍微研究了一下 改名实现如果单只是改名其实很简单，只需要几行即可实现： 1234@echo offfor /f &quot;delims=&quot; %%a in (&#x27;dir /ad/s/b &quot;Mesh&quot;&#x27;) do ren &quot;%%~a&quot; 01-Meshfor /f &quot;delims=&quot; %%b in (&#x27;dir /ad/s/b &quot;Texture&quot;&#x27;) do ren &quot;%%~b&quot; 00-Texturepause @echo off打开批处理黑窗口 for in do常用在查找匹配，满足条件后执行 dir /ad/s/b &quot;Mesh&quot;这行可以参考dir命令的用法，/ab在这里是只显示目录（如果是要显示文件是/a-d）/s显示目录和包含子目录，/b不显示日期大小等其他信息，&quot;Mesh&quot;会列出包含Mesh目录 pause这里会暂停一下按任意键继续 所以连起来就是列出包含Mesh和Texture的目录，然后用ren改名 SVN Rename批处理然而上面的简单改名这对于我遇到的实际情况不理想，有些资源是在SVN目录库里的，对于SVN来说，直接用ren等于删除Mesh旧目录，再新添加一个00-Mesh新目录，这会来带几个问题： log丢失，历史版本找不回来 如果文件多，占用空间很大，浪费大家带宽（每个人update会重新下载一遍） 所以最好是用SVN的命令来进行操作 然后发现用svn mv oldname newname就能完成 1svn mv Mesh 00-Mesh 移动，重命名，对svn来说都是这一个命令 所以大致思路就是用for in do来找到Mesh和Texture文件夹，然后用变量来做oldname和newname 12345678910111213141516171819202122232425@echo offsetlocal EnableDelayedExpansionfor /f &quot;delims=&quot; %%b in (&#x27;dir /ad/s/b &quot;Mesh&quot;&#x27;) do (set &quot;oldm=%%b&quot;set &quot;newm=!oldm:Mesh=00_Mesh!&quot;echo ------旧Mesh目录名称echo !oldm!echo ------新Mesh目录名称echo !newm!echo ------Mesh改名中...svn mv !oldm! !newm!)for /f &quot;delims=&quot; %%b in (&#x27;dir /ad/s/b &quot;Texture&quot;&#x27;) do (set &quot;oldt=%%b&quot;set &quot;newt=!oldt:Texture=01_Texture!&quot;echo ------旧Texture目录名称echo !oldt!echo ------新Texture目录名称echo !newt!echo ------Texture改名中...svn mv !oldt! !newt!)pause 一开始卡在变量这块很久，最后发现一定要有setlocal EnableDelayedExpansion，然后变量才可以在do()里用!oldm!这样，而不能用%oldm% set &quot;newm=!oldm:Mesh=00_Mesh!&quot;这行的操作是字符串替换，举例来说此时!oldm!为C:\\Users\\winte\\Desktop\\project\\Assets01\\Resource\\Mesh 会将此段字符串中的Mesh替换为00_Mesh,得到 C:\\Users\\winte\\Desktop\\project\\Assets01\\Resource\\00_Mesh 然后是一些交互上的完善，有个用到的结构 1234567@echo offecho 如需要撤销操作请按r,按其他任意键退出...set /p a=请输入r后回车:if &quot;%a%&quot;==&quot;r&quot; Goto abcexit /b:abc.... 这里有个判断，如果按下了r键，会触发Goto abc，然后跳转到:abc以下的脚本，否则会直接走exit /b退出脚本，很实用 一些Tips 将变量与批处理中的另一个变量的一部分匹配 https://www.thinbug.com/q/19056911 测试这段是好用的，用来检测一段字符串是否含有一段字符串 12345678910@echo offset &quot;h=Hello-World&quot;set &quot;f=This is a Hello-World test&quot;call set &quot;a=%%f:%h%=%%&quot;if not &quot;%a%&quot;==&quot;%f%&quot; goto :donepauseexit /b:doneecho it matchedpause 一个ping通隔段时间再ping，ping不通就关机的例子http://www.bathome.net/thread-12490-1-1.html 123456789101112131415161718@echo off:openping 192.168.1.90if %ERRORLEVEL%==0 goto Okif %ERRORLEVEL%==1 goto Noexit:Nocls&amp;echo 不通!关机操作shutdown -s -f -t 5000 ::5000秒后关机exit:Okcls&amp;echo.通，10分钟后再监测，请勿关闭本窗口ping 127.0.1 /n 600 &gt;nul ::600秒后执行检测goto open 如果要检测的是上段脚本执行以后的返回值，可以用到%ERRORLEVEL% https://www.jianshu.com/p/5e72aed76b71 不过%ERRORLEVEL%返回的是个数值，成功执行是0，不成功执行是非0，但是我用作svn命令执行判断的时候发现，有些指令即便不成功执行也返回0？懒得深究 找到另外一种方法直接判断返回的字符串 https://blog.csdn.net/hadsdn/article/details/78957361","categories":[],"tags":[{"name":"bat","slug":"bat","permalink":"https://winotmk.github.io/tags/bat/"}]},{"title":"SourceCraft服务器","slug":"MC","date":"2021-11-06T16:00:00.000Z","updated":"2023-08-25T03:29:47.943Z","comments":true,"path":"MC/","link":"","permalink":"https://winotmk.github.io/MC/","excerpt":"Java服务器地址：mc.winotmk.com:25465基岩服务器地址：mc.winotmk.com:19132 网站：Web地图：http://mcmap.winotmk.com","text":"Java服务器地址：mc.winotmk.com:25465基岩服务器地址：mc.winotmk.com:19132 网站：Web地图：http://mcmap.winotmk.com 服务器概况目前版本：spigot-1.20.1自有服务器，计划长期开服，主世界不清档，视情况可以增加副世界使用了Geyser插件，实现基岩版和Java版本同服，支持多种客户端，可以在手机和电脑上同时玩 （主机也行没测过 开服日期：2021-11-07容器化上云: 2023-08-25 世界结构：LobbyMainWorld -Nether -TheEndLyhWorld 现有传送门： Lobby去塔顶 Lobby去主世界（主传送门） Lobby去lyh存档世界 主世界往返湖边村落 更新log2023-08-25 版本由spigot-1.17.1更新至spigot-1.20.1 运行环境eci内运行，服务器文件nas上存储，环境和数据分离 服务器版本更新至1.20.1（顺带更新对应插件版本）禁用如下插件： PlaceholderAPI MiaoChat(被曝有后门) wolfyutilities ServerMinimap(似乎没啥用) Dynmap(web端地图，性能消耗巨大，体积巨大，暂移除) 常用玩家命令按T输入文本 第一次进服务器需要注册 1/reg 密码 密码 登录 1/l 密码 回主城lobby 1/spawn 回家（上次认得床） 1/home 回上次移动的地方（或上次死的地方) 1/back 移动到玩家身边（需要对方确认) 1/tpa 玩家名 开始首先选择一个版本如果你买过Windows版、主机，iPad之类的版本，可以选择基岩版或者在windows和MAC上玩Java版 附上Windows游戏购买链接java：https://www.minecraft.net/zh-hans/store/minecraft-java-edition基岩：https://www.minecraft.net/zh-hans/store/minecraft-windows10 Java版连接服务器如果购买过正版java版本直接进多人游戏输入服务器地址mc.winotmk.com:25465即可 如果没有购买这里提供原版纯净客户端： 链接：https://pan.baidu.com/s/1dl3mBgqhmvxPGMNVG2bRgw提取码：lijt 下载java运行环境https://www.oracle.com/java/technologies/downloads/#jdk17-windows 下载客户端运行HMCL登陆器 登录方式选离线模即可，写个名字，即游玩服务器时的名字 ps.如果启动失败请确保使用了java17 进游戏选择 第一次进服务器需要按T 然后输入/reg 密码 密码 注册 enjoy！ 基岩版连接服务器启动游戏选服务器，添加服务器 然后输入地址mc.winotmk.com端口19132 服务器插件列表以下部分玩家有兴趣可看 插件有功能类和玩法类多种，简单记录一下目前所有的插件 ActionHealth AncientGates AureliumSkills-Beta1.1.4 BlockLocker BossShopPro CatSeedLogin-1.3.9 Dynmap-3.2.1-spigot EssentialsX-2.19.0 EssentialsXChat-2.19.0 EssentialsXSpawn-2.19.0 Geyser-Spigot_基岩转发 GiftPack GSit LuckPerms-Bukkit-5.3.47 MiaoChat NekoMaid PocketGames Residence5.0.0.4 ServerMinimap Tree Feller-V2.2 Multiverse API前置类 CMILib1.0.4.2_圈地前置 PlaceholderAPI-2.10.10 SmartInvs-1.2.7 Vault Uniporter-1.3.2_Web管理前置 wolfyutilities-1.7.2.0 ActionHealth 在物品栏上显示血量https://www.spigotmc.org/resources/action-bar-health.2661/ AncientGates传送门 基础用法：本插件可以传送一切实体，包括玩家、运输工具、实体都能进入传送门这个插件不仅能跨服务器传送实体和输入指令，而且可以在进入另一个服务器时输入指令指令非常简单首先，需要输入指令打开功能：/gate setconf bungeeCordSupport true接下来你就可以使用任何关于BC的指令，创建传送门方法与普通的方法几乎无异/gate setto [id] [服务器] - 设置传送到的目的地/gate setbungeetype [id] [LOCATION/SERVER] - 在本地服务器上设置传送类型/gate addto [id] [服务器] - 添加传送到的服务器/gate remto [id] [服务器] - 删除可以传送到的服务器 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=584063 AureliumSkills技能系统 15 种独特的技能 (耕作Farming, 锻造Foraging, 挖矿Mining, 钓鱼Fishing, 采掘(旧版本翻译为掘土)Excavation, 箭术Archery, 防御Defense, 战斗Fighting, 耐力Endurance, 敏捷Agility, 炼金Alchemy, 附魔Enchanting, 巫术Sorcery, 治愈Healing, 以及锻造Forging) 6 种玩家属性 (生命Health, 力量Strength, 再生Regeneration, 幸运Luck, 智慧Wisdom, 以及韧性Toughness) 简洁明了, 能显示详细信息的 GUI 能够自定义物品和盔甲上的特殊属性 自定义打怪, 采集和钓鱼获得的特殊物品(掉落表/道具池, 原文为 Loot Table) 经验值来源及大小均可修改,Beta 1.1.1以后不再支持 MythicMobs 自定义怪物作为经验来源 多语言支持 ActionBar 与 BossBar 位置显示 可供开发者使用的 API 支持 MySQL /skills 或 /skill 或 /sk - 打开技能菜单,详见MCBBSMCbbs搬运：https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=1094927https://www.spigotmc.org/resources/aurelium-skills-advanced-skills-stats-abilities-and-more.81069/ BlockLocker 上锁插件 使用方法 1. 放置木牌对于容器类: 只需放置木牌即可,[私有]和玩家名会被自动生成.对于门类: 放置木牌在门上或周围的方块上即可,内容会自动生成. 其他:你也可以自己添加锁定信息,按照生成木牌的格式填写即可~ 2.编辑木牌右击木牌,输入”/blocklocker &lt;行数&gt; &lt;文本&gt;”来编辑木牌.指令简写: “/bl” = “/blocklocker”,方法为: “/bl &lt;行数&gt; &lt;文本&gt;”.可添加其他字符来避免被识别为玩家名,例如 “~”. 3.信任其他玩家在第二步的 &lt;文本&gt; 内容中添加你要信任的玩家名即可.如果想添加两个以上的玩家名,再放置一个木牌即可,内容会自动添加.第二个木牌添加内容 “‘[更多使用者]’ ‘[所有人]’”.“[所有人]”标签将允许所有人访问容器.请更改. MCbbs搬运：https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=1173296https://www.spigotmc.org/resources/blocklocker.3268/ BossShopPro已移除商店系统 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=829068商店页面编辑器：https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=1273221 CatSeedLogin 种子猫登录插件基岩入口和java入口都关闭了正版验证，所以加了登录插件来管理玩家的账号，此插件备选可替换AuthMe 登录 /login 密码 /l 密码注册密码 /register 密码 重复密码 /reg 密码 重复密码修改密码 /changepassword 旧密码 新密码 重复新密码 /changepw 旧密码 新密码 重复新密码 绑定邮箱 /bindemail set 邮箱 /bdmail set 邮箱用邮箱收到的验证码完成绑定 /bindemail verify 验证码 /bdmail verify 验证码忘记密码，请求服务器给自己绑定的邮箱发送重置密码的验证码 /resetpassword forget /repw forget用邮箱收到的验证码重置密码 /resetpassword re 验证码 新密码 /repw re 验证码 新密码 MCBBS:https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=847859 Dynmap 20230825更新：会消耗过多云服务资源暂移除 Web端卫星地图，还可3d显示，实时显示在线玩家位置，上帝视角 Mcbbs:https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=990539https://dynmap.us/builds/dynmap/ EssentialsX系列管理插件 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=619883 Geyser-Spigot 该插件让基岩版玩家可以进入本服务器 https://geysermc.org/https://www.mcbbs.net/thread-973002-1-1.html GiftPack已移除礼包插件 https://www.mcbbs.net/thread-1141658-1-1.html GSit 座椅子插件 /gsit(/sit) 坐在方块上/glgy(/lay) 躺在方块上/gcrawl(/crawl) 趴在方块上/gsittoggle(/sittoggle) 开关右键坐下/gsitreload(/gsitrl) 重载插件配置 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=1107053https://www.spigotmc.org/resources/gsit-modern-sit-seat-and-chair-lay-and-crawl-plugin-1-13-x-1-17-x.62325/ LuckPerms 权限管理https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=676818https://www.spigotmc.org/resources/luckperms.28140/ MiaoChat 聊天功能增加 20230825更新：移除，被曝有后台 聊天的时候输出%数字，代表展示手上物品%1-9 代表快捷物品栏1-9号格子的物品 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=631240 NekoMaid Wed后台管理插件 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=1230139 PocketGamesPo 34+口袋游戏|随时随地想玩就玩 玩家命令: /pocketgames|/pocket|/pg - 打开游戏菜单 /pg help - 打开插件帮助 /pg menu [玩家名] - 为指定玩家打开游戏菜单 /pg multiplayer [玩家名] - 为指定玩家打开多人游戏菜单 /pg spectate [玩家名] - 为指定玩家打开观战菜单 /pg play &lt;游戏ID&gt; [玩家名] - 让指定的玩家玩指定的游戏 /pg highscore &lt;游戏ID&gt; [玩家名] - 为指定玩家打开指定游戏的高分榜 /pg duel &lt;a/d/玩家名&gt; [游戏ID] - 接受邀请/拒绝邀请/邀请玩家进行多人游戏 /pg check &lt;玩家名&gt; - 检查玩家是否在玩游戏以及玩的什么游戏 /pg list - 插件的游戏列表 管理员命令: /pocketgamesadmin|/pga - 管理员帮助信息 /pga reset file &lt;文件名&gt; [只可填highscores.yml] /pga reset database [表] - 刷新数据库指定的表 /pga info - 插件信息 /pga reload - 重载插件 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=913753 Residence 圈地插件 /res ? —— 查看帮助 https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=631343 Serverminimap小地图 20230825更新：似乎没啥用，移除 /minimap - 为您提供小地图项目/waypoint help [command] - 为您提供有关此命令的信息/waypoint add [x] [z] - 在您当前的位置或指定的 x 和 z 坐标上添加一个航点。/waypoint list - 列出所有航点及其索引/waypoint remove - 删除索引为 的航点。注意：删除航点时，索引会发生变化。/waypoint hide [true|false] - 切换航点的可见性，或将其设置为给定的布尔值。 /lp group admin permission set minimap.fastupdate/lp group admin permission set minimap.command.minimap/lp group admin permission set minimap.command.waypoint.help/lp group admin permission set minimap.command.waypoint.list/lp group admin permission set minimap.command.waypoint.add/lp group admin permission set minimap.command.waypoint.remove/lp group admin permission set minimap.command.waypoint.hide https://dev.bukkit.org/projects/serverminimap Tree Feller一键砍树插件 https://www.spigotmc.org/resources/tree-feller.92998/ Multiverse多世界插件 #命令语法 mv [FILTER] [PAGE #]#发送版本信息至控制台 mv version -[pbg]#列出所有世界名称 mv list#列出综合信息 mv info [WORLD] [PAGE]*/mv info [世界名称] [页码] #创建世界mv create {名字} {环境} -s [种子] -g [生成器[:ID]] -t [生成器] [-n] -a [true|false] #复制某个世界mv clone {目标} {名字} -g [生成器[:ID]] #转换某个世界的类型mv import {名字} {环境} -g [生成器[:ID]] [-n] #重新加载配置文件mv reload #重置当前世界的默认出生点为脚下mv setspawn mcbbs:https://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=1016455 https://www.spigotmc.org/resources/multiverse-core.390/","categories":[],"tags":[{"name":"Minecraft","slug":"Minecraft","permalink":"https://winotmk.github.io/tags/Minecraft/"}]},{"title":"ArchLinux命令集","slug":"ArchLinux命令","date":"2021-10-23T16:00:00.000Z","updated":"2023-07-27T03:53:22.000Z","comments":true,"path":"ArchLinux命令/","link":"","permalink":"https://winotmk.github.io/ArchLinux%E5%91%BD%E4%BB%A4/","excerpt":"刚装完archlinux后ifconfig无法使用? 1# pacman -S net-tools dnsutils inetutils iproute2 Archlinux开启ssh服务命令：12345# systemctl enable sshd.service 开机启动# systemctl start sshd.service 立即启动# systemctl restart sshd.service 立即重启 关于systemctl:https://wiki.archlinux.org/title/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 比如：关闭开机启用KDE桌面环境 1# systemctl disable sddm 切换到root用户：1# su","text":"刚装完archlinux后ifconfig无法使用? 1# pacman -S net-tools dnsutils inetutils iproute2 Archlinux开启ssh服务命令：12345# systemctl enable sshd.service 开机启动# systemctl start sshd.service 立即启动# systemctl restart sshd.service 立即重启 关于systemctl:https://wiki.archlinux.org/title/Systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 比如：关闭开机启用KDE桌面环境 1# systemctl disable sddm 切换到root用户：1# su 以下无用，应该是旧版本PuTTY密钥算法支持有限，请更新PuTTY。。 用PuTTY登录报错： couldn’t agree a host key algorithm 解决，生成密钥：（出处：https://forums.centos.org/viewtopic.php?t=52892 1234567# cd /etc/ssh# ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key# vi /etc/ssh/sshd_configUncomment this line:# HostKey /etc/ssh/ssh_host_dsa_key# chgrp ssh_keys ssh_host_dsa_key# service sshd restart 如果putty连接报Network error:connection refused关闭防火墙 1# systemctl start iptables 安装jre环境1# pacman -S jre8-openjdk 高版本mc需要高JDK 1# pacman -S jre17-openjdk 切换java版本 1# sudo archlinux-java set java-17-openjdk 查看java状态 1# java -version 启动一个mc服务器https://cloud.tencent.com/developer/article/1622545 1# java -Xms1024MB -Xmx2048MB -jar iserver.jar 设置中文环境1# vim /etc/locale.conf 增加以下内容LANG=zh_CN.UTF-8 下次重新登录就是中文啦。可以输入date查看日期，如果显示中文，就说明设置正常啦 关于linux任务前后台处理：https://blog.csdn.net/timonium/article/details/116245621https://www.cnblogs.com/xiaoleiel/p/8349675.html 正在前台运行的命令暂停且放到后台： 1# Ctrl+z 12# jobs ## 查看后台进程编号# jobs -l ##查看进程PID，可以配合kill干掉进程 bg在后台继续执行，fg调回前台执行 12# bg [作业编号]# fg [作业编号] 一开始就后台执行：https://www.cnblogs.com/linnuo/p/9084125.html 1# java -jar shareniu.jar &amp; &amp;代表在后台运行 1# nohup java -jar shareniu.jar &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。 ps：我觉得上面的后台操作不好用不如试试Screen https://blog.csdn.net/han0373/article/details/81352663 screen -S yourname -&gt; 新建一个叫yourname的sessionscreen -ls -&gt; 列出当前所有的sessionscreen -r yourname -&gt; 回到yourname这个sessionscreen -d yourname -&gt; 远程detach某个sessionscreen -d -r yourname -&gt; 结束当前session并回到yourname这个session 回到MCSManager的面板 1# screen -r mcsm 看进程123# ps aux或者# top 压缩https://www.jianshu.com/p/59d93f942506 123456789101101-.tar格式解包：# tar xvf FileName.tar打包：# tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）02-.gz格式解压1：# gunzip FileName.gz解压2：# gzip -d FileName.gz压 缩：# gzip FileName03-.tar.gz格式解压：# tar zxvf FileName.tar.gz压缩：# tar zcvf FileName.tar.gz DirName","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"}]},{"title":"linux文件和目录权限","slug":"Linux权限","date":"1970-01-01T00:00:00.000Z","updated":"2021-10-23T17:07:10.000Z","comments":true,"path":"Linux权限/","link":"","permalink":"https://winotmk.github.io/Linux%E6%9D%83%E9%99%90/","excerpt":"*本文摘录整理为主 用ls -l查看权限： 12345678910111213141516171819202122232425262728293031323334353637383940文件属性 文件数 拥有者 所属的group 文件大小 建档日期 文件名 drwx--x--x 1 root wheel 6872 2 7 22:41 compressedPackage/drwxr-xr-x 1 liuml wheel 8620 2 15 09:32 wwwroot/ lrwxrwxrwx 1 liuml wheel 46 2 24 19:30 abc@ -&gt; home/abc-rwxr-xr-x 1 liuml wheel 68568 2 29 07:43 test* - 文件名栏位 文件后面的符号含义 - / ：表明是一个目录 - @ ：表明是到其它文件的符号链接 - * ：表明是一个可执行文件。- 对于权限设置的解释 - r 是读，w 是写，x 是执行 - 对应数字如下: - r = 4 w = 2 x = 1 - rwx ：4+2+1 = 7 - rw- ：4+2 = 6 - r-x ：4+1 = 5 - drwxr-xr-x ：755- 第 0-1位 文件类型 - “-” ：表示普通文件； - “d” ：表示目录； - “l” ：表示链接文件； - “p” ：表示管理文件； - “b” ：表示块设备文件； - “c” ：表示字符设备文件； - “s” ：表示套接字文件；- 第 2-4位 文件所有者权限 [User]- 第 5-7位 文件所有者所在组权限 [Group]- 第 8-10位 其他用户权限 [Others]- 没有的权限用 “-” 来表示————————————————版权声明：本文为CSDN博主「烟雨弥漫了江南」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u010324331/article/details/88035175/","text":"*本文摘录整理为主 用ls -l查看权限： 12345678910111213141516171819202122232425262728293031323334353637383940文件属性 文件数 拥有者 所属的group 文件大小 建档日期 文件名 drwx--x--x 1 root wheel 6872 2 7 22:41 compressedPackage/drwxr-xr-x 1 liuml wheel 8620 2 15 09:32 wwwroot/ lrwxrwxrwx 1 liuml wheel 46 2 24 19:30 abc@ -&gt; home/abc-rwxr-xr-x 1 liuml wheel 68568 2 29 07:43 test* - 文件名栏位 文件后面的符号含义 - / ：表明是一个目录 - @ ：表明是到其它文件的符号链接 - * ：表明是一个可执行文件。- 对于权限设置的解释 - r 是读，w 是写，x 是执行 - 对应数字如下: - r = 4 w = 2 x = 1 - rwx ：4+2+1 = 7 - rw- ：4+2 = 6 - r-x ：4+1 = 5 - drwxr-xr-x ：755- 第 0-1位 文件类型 - “-” ：表示普通文件； - “d” ：表示目录； - “l” ：表示链接文件； - “p” ：表示管理文件； - “b” ：表示块设备文件； - “c” ：表示字符设备文件； - “s” ：表示套接字文件；- 第 2-4位 文件所有者权限 [User]- 第 5-7位 文件所有者所在组权限 [Group]- 第 8-10位 其他用户权限 [Others]- 没有的权限用 “-” 来表示————————————————版权声明：本文为CSDN博主「烟雨弥漫了江南」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u010324331/article/details/88035175/ 图片来源：https://blog.csdn.net/zhuoya_/article/details/77418413 共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称d ：第一位表示文件类型 第一位字符 文件类型 d 文件夹 - 普通文件 l 链接 b 块设备文件 p 管道文件 c 字符设备文件 s 套接口文件 rxw和数值权限的对应： rxw 数值 r(读) 4 w(写) 2 x(执行) 1 所以，例如：rwx rw- r–7 6 4三个一组,rwx权限分别对应421相加得7,rw-对应42相加,r–对应4 图片来源：http://man.linuxde.net/chmod 举例：-rw-r–r–，即为644权限6对应4+2 rw-4对应 r–那么这个文件的权限就是所有者rw-,所属组r–,其他人r– 常用的linux权限对应： 数值 rxw 444 r–r–r– 600 rw——- 644 rw-r–r– 666 rw-rw-rw- 700 rwx—— 744 rwxr–r– 755 rwxr-xr-x 777 rwxrwxrwx 命令修改权限 权限管理命令chmod 修改文件或者目录的权限全拼: change permissions mode of a file语法: 123456chmod [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录][mode=421] [文件或目录]-R 递归修改u:所有者, g:所属组,o:其他人,a:所有;+:添加权限,-减少权限,=直接赋值成这个权限 创建目录mkdir时加权限 1$ mkdir -m=r-- letter 上面的命令会创建一个名为 letter 的目录，同时为目录所有者、用户组和其他用户 针对该目录赋予只读权限 mkdir命令小参考：在 Linux 下用 mkdir 命令来创建目录和子目录 参考：linux权限drwxrwxrwx所代表的意义 linux ls -l命令显示详解 linux更改文件(夹)权限或所有者 Linux 文件权限查看及修改","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"}]},{"title":"MayaMASH动力学做链子","slug":"Maya_MASH","date":"1970-01-01T00:00:00.000Z","updated":"2021-10-13T03:52:45.000Z","comments":true,"path":"Maya_MASH/","link":"","permalink":"https://winotmk.github.io/Maya_MASH/","excerpt":"","text":"","categories":[],"tags":[{"name":"Testing","slug":"Testing","permalink":"https://winotmk.github.io/tags/Testing/"},{"name":"Another Tag","slug":"Another-Tag","permalink":"https://winotmk.github.io/tags/Another-Tag/"}]},{"title":"hexo+github","slug":"hexo+github","date":"1970-01-01T00:00:00.000Z","updated":"2021-10-13T06:19:53.000Z","comments":true,"path":"hexo+github/","link":"","permalink":"https://winotmk.github.io/hexo+github/","excerpt":"https://winotmk.github.io/ github：https://github.com/winotmk/winotmk.github.io 总有一些零碎的想法，需要记录下来，写全面的文章没有时间，不写下来又会忘，日记app又不方便整理，同时也想利用一下树莓派，网上搜索便发现hexo+github部署的方式，于是想尝试尝试，一路遇到很多问题 主要参考：基于树莓派搭建Hexo博客部署到GitHub/Gitee 前期第二参考：hexo——轻量、简易、高逼格的博客 更详细的安装过程：GitHub+Hexo 搭建个人网站详细教程 hexo官方文档：https://hexo.io/docs/ hexo博客文档（似乎和上面有不少内容重叠）：https://theme-next.js.org/docs/ 安装hexo下载armv7版本的node.js：nodejs下载","text":"https://winotmk.github.io/ github：https://github.com/winotmk/winotmk.github.io 总有一些零碎的想法，需要记录下来，写全面的文章没有时间，不写下来又会忘，日记app又不方便整理，同时也想利用一下树莓派，网上搜索便发现hexo+github部署的方式，于是想尝试尝试，一路遇到很多问题 主要参考：基于树莓派搭建Hexo博客部署到GitHub/Gitee 前期第二参考：hexo——轻量、简易、高逼格的博客 更详细的安装过程：GitHub+Hexo 搭建个人网站详细教程 hexo官方文档：https://hexo.io/docs/ hexo博客文档（似乎和上面有不少内容重叠）：https://theme-next.js.org/docs/ 安装hexo下载armv7版本的node.js：nodejs下载 配置githubgit key配置：github每次需要输入密码和用户名的问题… 取消使用key令牌后还要输入密码：取消 SSH 私钥密码 后期配置hexo配置官方文档：https://hexo.io/zh-cn/docs/configuration 主题Next主题github：https://github.com/next-theme/hexo-theme-next Next主题的文档(ps.页面样式好看可参考)：第三方服务集成 Next主题代码框高亮预览设置：https://theme-next.js.org/highlight/ 资产文件夹https://hexo.io/docs/asset-folders 访客统计DevOps 访客数统计 &amp; google analytics 数据分析 将文章视图添加到您的 Hexo 博客(有LeanCloud和Firebase比较分析） 给hexo博客文章添加阅读次数统计 hexo next主题的leancloud安全插件github：https://github.com/theme-nex… 上面链接的说明：Leancloud访客统计插件重大安全漏洞修复指南 Firebase:https://console.firebase.google… 评论畅言：https://changyan.kuaizhan.com/v3/changyan/overviewvaline：https://valine.js.org 其他配置vscode：本来都是用putty打指令，用WinSCP访问我的目录操作的，但是WinSCP自带的文本编辑过与拉跨，有几次多打空格没看出来导致直接hexo g失败，后来突发奇想为啥不找个轻量级的IDE直接去写这些呢，于是用起了vscode Vscode配置ftp连接远程服务器（上传本地文件） 不过自己测试发现不好用，于是用了SSH FS这个vscode插件 相对路径./与../区别","categories":[],"tags":[]},{"title":"树莓派上架设TimeMachine服务","slug":"树莓派TimeMachine","date":"1970-01-01T00:00:00.000Z","updated":"2021-10-13T16:14:56.000Z","comments":true,"path":"树莓派TimeMachine/","link":"","permalink":"https://winotmk.github.io/%E6%A0%91%E8%8E%93%E6%B4%BETimeMachine/","excerpt":"命令前半参考：从此Mac上的文件再也不会丟了 后半参考：如何自己搭建一个Time Machine服务器 挂载硬盘目录 1sudo mount /dev/sda2 /mnt/WinSource 1.安装netatalk和avahi（自己感觉avahi不装也行 1sudo apt install netatalk avahi-daemon -y 2.创建账户wintm来访问TimeMachine，至少别用root，root访问不能！ 1useradd -c &quot;Time machine&quot; -m -s /bin/bash wintm 然后设置密码 1sudo passwd wintm","text":"命令前半参考：从此Mac上的文件再也不会丟了 后半参考：如何自己搭建一个Time Machine服务器 挂载硬盘目录 1sudo mount /dev/sda2 /mnt/WinSource 1.安装netatalk和avahi（自己感觉avahi不装也行 1sudo apt install netatalk avahi-daemon -y 2.创建账户wintm来访问TimeMachine，至少别用root，root访问不能！ 1useradd -c &quot;Time machine&quot; -m -s /bin/bash wintm 然后设置密码 1sudo passwd wintm 3.配置netatalk 1sudo nano /etc/netatalk/AppleVolumes.default 这个文件似乎一行代表一个服务可以在 12345# The line below sets some DEFAULT, starting with Netatalk 2.1.:DEFAULT: options:upriv,usedots# By default all users have access to their home directories.~/ &quot;Home Directory&quot; 下面加上一行 12/mnt/WinSource/TimeMachine WinMachine allow:wintm options:tm#挂在硬盘里的文件夹 afp服务名 允许wintm用户登陆 开启timemachine 4.重启服务 12sudo service netatalk restartsudo service avahi-daemon restart 一些坑 试图直接使用root账户连接，在这里卡了很久，还尝试在AppleVolumes.default设置里写上例如 /mnt/WinSource/TimeMachine WinMachine allow:root rwlist:root options:tm 翻到这篇：[NAS之旅]-基于Centos7搭建Netatalk为Windows增加AFP协议 才忽然醒悟，root用户是禁止登录AFP服务的，得嘞，新开个专门的用户吧 提到了新建一个用户来跑timemachine：如何自己搭建一个Time Machine服务器 一开始习惯将硬盘挂载到/root/WinSource，然鹅这似乎导致即便mac上TimeMachine连接上了也报错没法开始备份，想想也是wintm用户没有权限进root。。总结为避免不必要的麻烦以后硬盘不挂/root里，这里我挂进了/mnt ps:当时还试图对/root/WinSource使用chown 1sudo chown -R wintm:wintm /root/WinSource 见这篇：用树莓派实现 Time Capsule 无解，chown改不了WinSource目录的所有者，root强而有力，认输 补充连接NetaTalk官方文档和下载：http://netatalk.sourceforge.net/3.1/htmldocs/afp.conf.5.html AFP Netatalk 分享配置 (又名 Apple Time Machine). 使用netatalk打造一款属于自己的Time-Machine在线备份服务器","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"rashbeerypi","slug":"rashbeerypi","permalink":"https://winotmk.github.io/tags/rashbeerypi/"}]},{"title":"安装ArchLinux系统（详细过程）","slug":"安装Arch","date":"1970-01-01T00:00:00.000Z","updated":"2021-10-25T14:36:08.000Z","comments":true,"path":"安装Arch/","link":"","permalink":"https://winotmk.github.io/%E5%AE%89%E8%A3%85Arch/","excerpt":"参考文章：https://zhuanlan.zhihu.com/p/138951848 官方WIKI安装指南（上文和本文大致流程基于此）：https://wiki.archlinux.org/title/Installation_guide 家里旧笔记本淘汰装个Linux跑跑服务发挥余热，这里是彻底格式化硬盘新安装，而不需要多系统引导 我的环境有： 2核 Intel(R) Pentium(R) CPU 997 @ 1.60GHz 4GB 1600内存 UEFI启动（不能为BIOS） Samsang 850 EVO 250G 2.5寸SATA接口 无线网卡拆掉了，用得是网线 路由器上全局梯子（所以我没有换源，用官方源速度足够了） 准备镜像https://archlinux.org/download/下载发行版的Linux的ISO然后制作U盘启动，我是在mac下用balenaEtcher做的，操作非常方便","text":"参考文章：https://zhuanlan.zhihu.com/p/138951848 官方WIKI安装指南（上文和本文大致流程基于此）：https://wiki.archlinux.org/title/Installation_guide 家里旧笔记本淘汰装个Linux跑跑服务发挥余热，这里是彻底格式化硬盘新安装，而不需要多系统引导 我的环境有： 2核 Intel(R) Pentium(R) CPU 997 @ 1.60GHz 4GB 1600内存 UEFI启动（不能为BIOS） Samsang 850 EVO 250G 2.5寸SATA接口 无线网卡拆掉了，用得是网线 路由器上全局梯子（所以我没有换源，用官方源速度足够了） 准备镜像https://archlinux.org/download/下载发行版的Linux的ISO然后制作U盘启动，我是在mac下用balenaEtcher做的，操作非常方便 然后重启电脑从U盘启动 硬盘准备进入U盘系统后先连pacman试试 1pacman -Syyy 检查硬盘1lsblk 建立分区1cfdisk /dev/sda 选择New 回车，然后选择Write 回车 输入 yes 回车写入完成 选择Quit 回车退出 格式化将刚刚分好的区格式化为ext4格式，这里认准分区号sda1 1mkfs.ext4 /dev/sda1 挂载分区sda1 1mount /dev/sda1 /mnt 安装系统1pacstrap /mnt base linux linux-firmware nano 生成fstab文件1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 检查生成的fstab文件 1cat /mnt/etc/fstab 配置新系统切换到装好的系统1arch-chroot /mnt 设置时区1ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 设置locale1nano /etc/locale.gen Ctrl+W 输入 #en_US 回车 找到UTF-8那一行 删掉前面的# Ctrl+W 输入 #zh_CN 回车 找到UTF-8那一行 删掉前面的#Ctrl+X 然后Y保存退出生成locale 1locale-gen 创建并写入/etc/locale.conf文件 1nano /etc/locale.conf 填入内容，注意这里只能填这个 1LANG=en_US.UTF-8 创建并写入hostname1nano /etc/hostname 我这里名字叫WinArch保存退出 修改hosts1nano /etc/hosts 写入内容如图（中间的空白用tab而非空格），arch替换为你之前在hostname里写入的内容，其他都按照图里面的写（注意最后一行的ip是127.0.1.1） 保存退出 建议上述编辑的内容都用cat输出检查一下 root用户创建密码1passwd 然后输入并确认密码 装启动器和一些软件包含了一些常用到的软件 1pacman -S grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git sudo intel的cpu，需要安装intel的微码文件 1pacman -S intel-ucode 完成之后输入 1grub-install /dev/sda 注意是硬盘位置不是分区位置，硬盘上也只有刚刚安装的Arch系统 生成grub.cfg 1grub-mkconfig -o /boot/grub/grub.cfg 出现吧啦吧啦done就完成了 退出新系统重启12exitreboot 不装桌面环境的话，到这步即可使用了，后续需要什么再装不迟 新建用户并授权1useradd -m -G wheel winotmk 我的用户是winotkm，这里主要是创建一个非root的账户，桌面环境一般无法用root登陆的创建密码 1passwd winotmk 授权 1EDITOR=nano visudo Ctrl+W 输入 # %wheel 回车 找到这行 删除前面的 #（取消注释） 安装Display Server和Display Manager1pacman -S xorg 然后我喜欢KDE桌面，所以装： 1pacman -S sddm 设置开机启动 1systemctl enable sddm PS.取消开机启动是 1systemctl disable sddm 安装Desktop EnvironmentKDE： 1pacman -S plasma kde-applications packagekit-qt5 安装中文的字体 1pacman -S noto-fonts-cjk 好了，大功告成 1reboot","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"}]},{"title":"树莓派路由器","slug":"树莓派路由器","date":"1970-01-01T00:00:00.000Z","updated":"2023-06-17T16:39:19.000Z","comments":true,"path":"树莓派路由器/","link":"","permalink":"https://winotmk.github.io/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B7%AF%E7%94%B1%E5%99%A8/","excerpt":"树莓派CM4的 openWrt web界面安装中文https://www.jianshu.com/p/da01ce070688更新包目录： 1opkg update 这里一开始我不行，ping1.1.1.1和ping8.8.8.8都ping不通，然后忽然想起自己的科学梯子路由网关是192.168.50.4改之!! 可能还不行这俩防火墙设置一下 如果还不行DNS记得指定一下 这下就能通了 PS也可以点配置opkg，然后加一条 1src/gz openwrt_packages https://mirrors.ustc.edu.cn/openwrt/releases/22.03.5/packages/aarch64_cortex-a72/packages/ 把源换为国内 然后 1opkg install luci-i18n-base-zh-cn 提示 1Configuring luci-i18n-base-zh-cn 再回来看web界面就已经是中文了","text":"树莓派CM4的 openWrt web界面安装中文https://www.jianshu.com/p/da01ce070688更新包目录： 1opkg update 这里一开始我不行，ping1.1.1.1和ping8.8.8.8都ping不通，然后忽然想起自己的科学梯子路由网关是192.168.50.4改之!! 可能还不行这俩防火墙设置一下 如果还不行DNS记得指定一下 这下就能通了 PS也可以点配置opkg，然后加一条 1src/gz openwrt_packages https://mirrors.ustc.edu.cn/openwrt/releases/22.03.5/packages/aarch64_cortex-a72/packages/ 把源换为国内 然后 1opkg install luci-i18n-base-zh-cn 提示 1Configuring luci-i18n-base-zh-cn 再回来看web界面就已经是中文了 如果要开启sftp传输服务https://github.com/twn39/code/issues/279 开启sftp的话可以很方便用WinSCP登录，文件管理神器那么如何启用 sftp 服务呢？先安装对应的软件： opkg install vsftpd openssh-sftp-server设置系统开启后自动启动 sftp 服务： 1/etc/init.d/vsftpd enable 启动 sftp 服务： 1/etc/init.d/vsftpd start 这样 Openwrt 就已经启用了 sftp 服务了，可以使用客户端进行文件的传输。 装网卡驱动我的CM4拓展板子是微雪的这个https://www.waveshare.net/wiki/CM4-DUAL-ETH-MINI有两个网口ETH0是原生ETH1是PCIe转出来的，需要安装RTL8111H芯片的网卡驱动，查了一下软件包里是有的https://openwrt.org/packages/pkgdata/kmod-r8169那么就好办了安装就行了： 1opkg install kmod-r8169 安装完成以重启openwrt我们看到这里已经读到了eth1口 设置路由器WAN口 添加新端口，设备选装好驱动以后出现的eth1，协议我选pppoe因为我拿路由拨号 如果要自己加安装包： 放到一个tmp目录里 CD到tmp目录 1opkg install *.ipk 关于扩容挂载点 参考资料： https://www.jianshu.com/p/e83459242afb https://blog.csdn.net/ls0111/article/details/128769859 PS我选的是树莓派cpu对应的ext4文件系统的固件，SQUASHFS就不碰了不熟悉 首先安装安装cfdisk，注意这里要先更新下opkg 12opkg updateopkg install cfdisk 然后打开cfdisk 1cfdisk 但是我打不开比如我的这块硬盘是内置EMMC硬盘, 显示名称是/dev/mmcblk0.一般的内置硬盘应该是/dev/sda之类的. 使用cfdisk命令，进入分区页面 1cfdisk /dev/mmcblk0 如果普通是内置硬盘 1cfdisk 按照参考资料中的教程一路继续做到格式化新分区就可以了，注意mmcblk0p3要替换成自己的盘符 1mkfs.ext4 /dev/mmcblk0p3 运行 1fdisk -l 或者 1df -h 命令，查看是否成功创建新分区。 然后在Luci web界面里面增加挂载点：我是直接从OpenWrt官网下的，不是修改版，所以木有这个选项。 12opkg updateopkg install block-mount 重启路由，界面会有挂载点出现，进入 挂载刚才格式化的硬盘以后 复制这段 1234567mkdir -p /tmp/introotmkdir -p /tmp/extrootmount --bind / /tmp/introotmount /dev/sda1 /tmp/extroottar -C /tmp/introot -cvf - . | tar -C /tmp/extroot -xf -umount /tmp/introotumount /tmp/extroot 其中的 1mount /dev/sda1 /tmp/extroot 要改为 1mount /dev/mmcblk0p3 /tmp/extroot 满血了！！","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"rashbeerypi","slug":"rashbeerypi","permalink":"https://winotmk.github.io/tags/rashbeerypi/"}]},{"title":"流量异常排查","slug":"流量异常排查","date":"1970-01-01T00:00:00.000Z","updated":"2023-06-17T16:44:49.000Z","comments":true,"path":"流量异常排查/","link":"","permalink":"https://winotmk.github.io/%E6%B5%81%E9%87%8F%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/","excerpt":"","text":"挖个坑。。。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"}]},{"title":"生成秘钥连接至github————用来推hexo","slug":"生成秘钥连接至github_用来推hexo","date":"1970-01-01T00:00:00.000Z","updated":"2023-06-17T16:44:48.000Z","comments":true,"path":"生成秘钥连接至github_用来推hexo/","link":"","permalink":"https://winotmk.github.io/%E7%94%9F%E6%88%90%E7%A7%98%E9%92%A5%E8%BF%9E%E6%8E%A5%E8%87%B3github_%E7%94%A8%E6%9D%A5%E6%8E%A8hexo/","excerpt":"","text":"生成秘钥1ssh-keygen -t ed25519 -C &quot;550330147@qq.com&quot; 邮箱自然是我的git注册邮箱 如果修改passphrade密码1ssh-keygen -p -f ~/.ssh/id_ed25519 直接enter即密码为空，这是秘钥的密码 复制秘钥到github打开/root/.ssh/id_ed25519.pub复制到这里https://github.com/settings/ssh/new PS官方已不推荐用rsa加密 测试1ssh -T git@github.com 这里输入yes成功！","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"github","slug":"github","permalink":"https://winotmk.github.io/tags/github/"}]}],"categories":[{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/categories/docker/"},{"name":"python","slug":"python","permalink":"https://winotmk.github.io/categories/python/"},{"name":"web","slug":"web","permalink":"https://winotmk.github.io/categories/web/"},{"name":"小板子","slug":"小板子","permalink":"https://winotmk.github.io/categories/%E5%B0%8F%E6%9D%BF%E5%AD%90/"},{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/categories/linux/"},{"name":"stable diffusion","slug":"stable-diffusion","permalink":"https://winotmk.github.io/categories/stable-diffusion/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://winotmk.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://winotmk.github.io/tags/docker/"},{"name":"calibre_web","slug":"calibre-web","permalink":"https://winotmk.github.io/tags/calibre-web/"},{"name":"minecraft","slug":"minecraft","permalink":"https://winotmk.github.io/tags/minecraft/"},{"name":"python","slug":"python","permalink":"https://winotmk.github.io/tags/python/"},{"name":"开发","slug":"开发","permalink":"https://winotmk.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"web","slug":"web","permalink":"https://winotmk.github.io/tags/web/"},{"name":"博客","slug":"博客","permalink":"https://winotmk.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"streamlit","slug":"streamlit","permalink":"https://winotmk.github.io/tags/streamlit/"},{"name":"rashbeerypi","slug":"rashbeerypi","permalink":"https://winotmk.github.io/tags/rashbeerypi/"},{"name":"嵌入式开发","slug":"嵌入式开发","permalink":"https://winotmk.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"},{"name":"C","slug":"C","permalink":"https://winotmk.github.io/tags/C/"},{"name":"PICO","slug":"PICO","permalink":"https://winotmk.github.io/tags/PICO/"},{"name":"ftp","slug":"ftp","permalink":"https://winotmk.github.io/tags/ftp/"},{"name":"阿里云","slug":"阿里云","permalink":"https://winotmk.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"AI","slug":"AI","permalink":"https://winotmk.github.io/tags/AI/"},{"name":"stable diffusion","slug":"stable-diffusion","permalink":"https://winotmk.github.io/tags/stable-diffusion/"},{"name":"proxy","slug":"proxy","permalink":"https://winotmk.github.io/tags/proxy/"},{"name":"NAS","slug":"NAS","permalink":"https://winotmk.github.io/tags/NAS/"},{"name":"SVN","slug":"SVN","permalink":"https://winotmk.github.io/tags/SVN/"},{"name":"WinNote","slug":"WinNote","permalink":"https://winotmk.github.io/tags/WinNote/"},{"name":"eci","slug":"eci","permalink":"https://winotmk.github.io/tags/eci/"},{"name":"hexo","slug":"hexo","permalink":"https://winotmk.github.io/tags/hexo/"},{"name":"next","slug":"next","permalink":"https://winotmk.github.io/tags/next/"},{"name":"bat","slug":"bat","permalink":"https://winotmk.github.io/tags/bat/"},{"name":"Minecraft","slug":"Minecraft","permalink":"https://winotmk.github.io/tags/Minecraft/"},{"name":"Testing","slug":"Testing","permalink":"https://winotmk.github.io/tags/Testing/"},{"name":"Another Tag","slug":"Another-Tag","permalink":"https://winotmk.github.io/tags/Another-Tag/"},{"name":"github","slug":"github","permalink":"https://winotmk.github.io/tags/github/"}]}